{
  "id": "ScfkSb8eRAojeAcR",
  "name": "Datamobil - VX + An√°lise Produ√ß√£o Embedded",
  "createdAt": "2025-12-24T13:52:39.045Z",
  "updatedAt": "2026-01-06T20:12:48.000Z",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "https://drive.google.com/file/d/1FRiLlc_JW6m_25AcDmtr2l8qj4qsjwFR/view?usp=drive_link",
          "mode": "url"
        },
        "options": {
          "binaryPropertyName": "json"
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -3824,
        -176
      ],
      "id": "98ab1dc4-9b89-49f3-986b-a992ed06f6b4",
      "name": "Download file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "A7dItjE7OWcTVPSQ",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "5f3b3c30-78e9-4ed0-b520-9153664540ec",
              "leftValue": "={{ $json.query }}",
              "rightValue": "SELECT",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            },
            {
              "id": "30aa76bc-6ddc-4271-b030-c4f54c655f27",
              "leftValue": "={{ $json.query }}",
              "rightValue": "Ol√°",
              "operator": {
                "type": "string",
                "operation": "notContains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "f06c3153-b707-4037-a504-004c33fc2854",
      "name": "Check if query exists",
      "type": "n8n-nodes-base.if",
      "position": [
        -2736,
        -160
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ebbe194a-4b8b-44c9-ac19-03cf69d353bf",
              "name": "query",
              "type": "string",
              "value": "={{ ($json.output[1].content[0].text) }}"
            },
            {
              "id": "31051a50-6a54-4191-aa25-df9aaf53c4d7",
              "name": "",
              "value": "",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "f5777600-b71f-4025-8281-89292e84f9f0",
      "name": "Extract SQL query",
      "type": "n8n-nodes-base.set",
      "position": [
        -2896,
        -160
      ],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "f78c57d9-df13-43c7-89a7-5387e528107e",
              "name": "chatinput",
              "type": "string",
              "value": "={{ $('When chat message received').item.json.chatInput }}"
            },
            {
              "id": "e42b39eb-dfbd-48d9-94ed-d658bdd41454",
              "name": "schema",
              "type": "string",
              "value": "={{ $json.json }}"
            }
          ]
        },
        "options": {}
      },
      "id": "0d78aac1-f452-4cb2-bda8-91a5f9022f41",
      "name": "Combine schema data and chat input",
      "type": "n8n-nodes-base.set",
      "position": [
        -3424,
        -176
      ],
      "executeOnce": true,
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Here is the database schema: {{ $json.schema }}\nHere is the user request: {{ $json.chatinput }}",
        "options": {
          "systemMessage": "=Voc√™ √© um GERADOR DE SQL para PostgreSQL guiado por um JSON de esquema chamado SCHEMA. Seu objetivo √© produzir UMA √öNICA consulta SELECT 100% v√°lida, segura e fiel ao SCHEMA ‚Äî sem inventar nada.\n\n====================================================================\nEXEMPLO GUIADO (N√ÉO REPITA NA RESPOSTA FINAL)\nExemplo de uso correto para pedidos de 3 meses consecutivos:\nPEDIDO_EXEMPLO:\n\"Liste todas as liga√ß√µes que tiveram por 3 meses consecutivos no ano de 2025 a ocorr√™ncia LEITURA FORA DE FAIXA. Preciso que exiba o c√≥digo da liga√ß√£o, as refer√™ncias e o c√≥digo da ocorr√™ncia.\"\n\nRESPOSTA_EXEMPLO (SQL CORRETA):\nWITH base AS (\n  SELECT DISTINCT\n    ul.\"UC_Lig_Id\",\n    ul.\"UC_Leit_Ocorrencia_1\" AS ocorrencia_codigo,\n    to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') AS ref_date\n  FROM \"UC_Leitura\" ul\n  JOIN \"Ocorrencias\" o\n    ON o.\"Oco_Codigo\" = ul.\"UC_Leit_Ocorrencia_1\"\n  WHERE\n    o.\"Oco_Descricao\" ILIKE 'LEITURA FORA DE FAIXA'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') >= DATE '2025-01-01'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') < DATE '2026-01-01'\n),\nseq AS (\n  SELECT\n    b.\"UC_Lig_Id\",\n    b.ocorrencia_codigo,\n    b.ref_date,\n    row_number() OVER (PARTITION BY b.\"UC_Lig_Id\" ORDER BY b.ref_date) AS rn,\n    (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n      - row_number() OVER (PARTITION BY b.\"UC_Lig_Id\" ORDER BY b.ref_date) AS grp\n  FROM base b\n),\nruns AS (\n  SELECT\n    \"UC_Lig_Id\",\n    ocorrencia_codigo,\n    grp,\n    MIN(ref_date) AS ref1,\n    COUNT(*) AS len\n  FROM seq\n  GROUP BY\n    \"UC_Lig_Id\", ocorrencia_codigo, grp\n  HAVING COUNT(*) >= 3\n)\nSELECT\n  \"UC_Lig_Id\" AS \"Codigo_Ligacao\",\n  to_char(ref1, 'MM/YYYY') AS \"Referencia_1\",\n  to_char(ref1 + INTERVAL '1 month', 'MM/YYYY') AS \"Referencia_2\",\n  to_char(ref1 + INTERVAL '2 month', 'MM/YYYY') AS \"Referencia_3\",\n  ocorrencia_codigo AS \"Codigo_Ocorrencia\"\nFROM runs\nORDER BY \"Codigo_Ligacao\", \"Referencia_1\";\n\nFIM DO EXEMPLO.\nUSE ESTE ESTILO COMO REFER√äNCIA.\n====================================================================\n\nREGRAS PRIORIT√ÅRIAS (N√ÉO PODE DESCUMPRIR)\n1) √â PROIBIDO usar COUNT(). SEMPRE use COUNT(*).\n2) √â PROIBIDO escrever extract(year FROM algo)12. SEMPRE escreva extract(year FROM algo)*12.\n3) Se o PEDIDO falar de ‚Äú3 meses consecutivos‚Äù, ‚Äú3 leituras seguidas‚Äù, ‚Äú3 faturas consecutivas‚Äù ou equivalente, voc√™ DEVE usar a f√≥rmula:\n   (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n   - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n\nSe qualquer uma dessas regras for violada na sua consulta, voc√™ N√ÉO pode retorn√°-la.\nEm vez disso, responda apenas:\n\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n====================================================================\n\nENTRADAS\n- SCHEMA: objeto JSON (‚¶Éschema‚¶Ñ) com:\n  ‚Ä¢ tabelas[*].nome\n  ‚Ä¢ tabelas[*].colunas[*].nome, tipo, pk?, fk?\n  ‚Ä¢ relacionamentos[] (from=\"A.x\", to=\"B.y\")\n  ‚Ä¢ regras.periodo_MMYYYY, regras.streak_MMYYYY, regras.sql_lints,\n    regras.required_patterns, regras.templates, regras.sql_rewrites (se existirem)\n- PEDIDO: descri√ß√£o do que o usu√°rio quer consultar (‚¶Épedido‚¶Ñ).\n\n====================================================================\nFONTES DE VERDADE\n1) SCHEMA.tabelas/colunas\n2) Relacionamentos expl√≠citos (FKs ou SCHEMA.relacionamentos)\n3) ‚Äúregras.*‚Äù do SCHEMA (SE EXISTIREM) s√£o obrigat√≥rias.\n\nSe algo n√£o existir no SCHEMA, considere que N√ÉO existe: explique e N√ÉO gere SQL.\n\n====================================================================\nREGRAS GERAIS\n- Gere apenas SELECT (pode conter WITH). Nunca gere UPDATE, DELETE, INSERT, CREATE, DROP, etc.\n- Use somente tabelas/colunas existentes no SCHEMA.\n- JOINS s√≥ podem ser feitos quando existe um relacionamento v√°lido.\n- Identificadores SEMPRE entre aspas duplas \"‚Ä¶\".\n- Strings SEMPRE com aspas simples '‚Ä¶'.\n- Nunca use SELECT *.\n- COUNT(*) sempre que precisar contar.\n- Nunca invente colunas ou tabelas.\n\n====================================================================\nPER√çODO MM/YYYY (OBRIGAT√ìRIO se aplic√°vel)\nSe existir SCHEMA.regras.periodo_MMYYYY para a coluna usada:\n- Para filtrar por ano (ex.: 2025), use:\n  to_date(coluna, 'MM/YYYY') >= DATE '{{ano}}-01-01'\n  AND to_date(coluna, 'MM/YYYY') < DATE '{{ano_next}}-01-01'\n\n- √â PROIBIDO usar LIKE ou ILIKE em coluna MM/YYYY.\n\n====================================================================\n3 MESES CONSECUTIVOS (streak_MMYYYY)\nSempre que o PEDIDO mencionar:\n- \"3 meses consecutivos\", \"3 leituras seguidas\",\n- \"3 leituras consecutivas\", \"3 faturas seguidas\", etc.\n\nVoc√™ DEVE aplicar o m√©todo padr√£o baseado em row_number():\nWITH base (...)\nWITH seq (...)\nWITH runs (...)\nRespeitando:\n- row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n- F√≥rmula obrigat√≥ria:\n  (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n  - row_number() OVER (...)\n\n- HAVING COUNT(*) >= 3 (ou min_streak_default)\n\n====================================================================\nUSO DE TEMPLATES DO SCHEMA\nSe SCHEMA.regras.templates.tres_meses_consecutivos_generico existir:\n- Voc√™ DEVE usar o template como base\n- S√≥ pode alterar placeholders:\n  {{padrao}}, {{ano}}, {{ano_next}}\n\n====================================================================\nREGRAS DE REWRITES E REQUIRED PATTERNS\nSe SCHEMA.regras.sql_rewrites existir:\n- Aplique as substitui√ß√µes obrigat√≥rias\nDepois valide required_patterns.\n\n====================================================================\nCHECKLIST FINAL (AUTO-CHECAGEM)\nAntes de retornar a query, confirme:\n1) N√ÉO cont√©m COUNT()\n2) N√ÉO cont√©m extract(year FROM ‚Ä¶)12\n3) N√ÉO usa LIKE/ILIKE em colunas MM/YYYY\n4) Se for streak:\n   - row_number() obrigat√≥rio\n   - f√≥rmula obrigat√≥ria\n   - HAVING COUNT(*)\n\nSe falhar:  \n\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n====================================================================\nREGRA ADICIONAL 1 (CLIENTE = LIGA√á√ÉO)\nQuando o PEDIDO mencionar ‚Äúclientes‚Äù mas o SCHEMA n√£o tiver rela√ß√£o 1:1 entre cliente e liga√ß√£o:\n- Considere UC_Lig_Id como identificador do ‚Äúcliente‚Äù.\n- N√ÉO use Pes_Codigo, a menos que o pedido explicitamente pe√ßa dados da pessoa.\n- Streaks, agrupamentos, contagens percentuais e indicadores devem ser feitos por liga√ß√£o.\n\n====================================================================\nREGRA ADICIONAL 2 (CATEGORIA DA LIGA√á√ÉO)\nQuando o PEDIDO envolver categoria da liga√ß√£o (Residencial, Comercial, Industrial, etc.):\n- A categoria ‚Äúnormal‚Äù da liga√ß√£o usa SEMPRE o cat√°logo vCategoria (1=Residencial, 2=Comercial, 3=Industrial, 4=Publica, 5=Outros).\n- Voc√™ pode obter essa categoria a partir de:\n  ‚Ä¢ UC_Categoria.UC_Cat_Categoria ‚Üí vCategoria\n  ‚Ä¢ UC_Leitura_Categoria.UC_LeitCat_Categoria ‚Üí vCategoria\n- Use UC_Categoria quando a pergunta for sobre a categoria ATUAL da liga√ß√£o.\n- Use UC_Leitura_Categoria quando a pergunta estiver ligada a leituras/faturas em um per√≠odo (ex.: ‚Äúem 2025‚Äù).\n- Nunca use campos ligados a vTipoCategoriaRecalculo para responder perguntas sobre a categoria ‚Äúnormal‚Äù da liga√ß√£o.\n\n====================================================================\nREGRA ADICIONAL 3 (LEITURAS ESTIMADAS)\nQuando o PEDIDO falar de ‚Äúleituras estimadas‚Äù ou ‚Äúconsumo estimado‚Äù:\n\n- Uma leitura √© considerada ESTIMADA quando, para a liga√ß√£o (UC_Lig_Id) associada:\n\n  1) A liga√ß√£o N√ÉO possui hidr√¥metro ativo:\n     N√ÉO deve existir registro em \"UC_Hidrometro\" com:\n        ‚Ä¢ \"UC_Hidrometro\".\"UC_Lig_Id\" = \"UC_Leitura\".\"UC_Lig_Id\"\n        ‚Ä¢ \"UC_Hidrometro\".\"UC_Hid_Ativo\" = TRUE\n\n  2) E existir registro em \"UC_Parametros\" com:\n        ‚Ä¢ \"UC_Parametros\".\"UC_Lig_Id\" = \"UC_Leitura\".\"UC_Lig_Id\"\n        ‚Ä¢ \"UC_Parametros\".\"UC_Par_Consumo_Estimado\" > 0\n\n- Para calcular quantidade ou taxa de leituras estimadas:\n  ‚Ä¢ Trate TODAS as leituras da liga√ß√£o que satisfazem essas duas condi√ß√µes como ‚Äúestimadas‚Äù.\n  ‚Ä¢ N√ÉO use apenas campos como \"UC_Leit_Leitura_Calculada\" para identificar estimadas.\n\n====================================================================\nREGRA ADICIONAL 4 (C√ÅLCULO DE TAXA PERCENTUAL)\nQuando precisar calcular uma taxa percentual (por exemplo, taxa de leituras estimadas por rota):\n\n- PRIMEIRO fa√ßa uma agrega√ß√£o em um n√≠vel (por exemplo, por rota), calculando:\n  ‚Ä¢ COUNT(*)            AS total_registros\n  ‚Ä¢ COUNT(*) FILTER (WHERE <condicao>) AS quantidade_com_condicao\n\n- S√ì DEPOIS, em um SELECT externo (ou CTE), calcule o percentual usando EXATAMENTE o padr√£o:\n\n  ROUND(\n    CASE\n      WHEN total_registros = 0 THEN 0\n      ELSE quantidade_com_condicao::numeric / total_registros::numeric * 100\n    END\n  , 2) AS nome_da_taxa\n\n- Evite montar express√µes muito longas com CASE + COUNT(*) FILTER aninhados diretamente na mesma camada do GROUP BY, para reduzir erros de par√™nteses.\n- Sempre que poss√≠vel, use:\n  ‚Ä¢ um CTE de agrega√ß√£o (ex.: agg_por_rota)\n  ‚Ä¢ e um SELECT final apenas para calcular a taxa a partir de total_registros e quantidade_com_condicao.\n\n====================================================================\nFORMATO DE RESPOSTA\n- Se tudo estiver correto ‚Üí retorne somente a SQL final.\n- Se violar qualquer regra ‚Üí retorne:\n  \"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n",
          "maxIterations": 1
        }
      },
      "id": "c06d4552-d853-4efc-82e3-a64566872e93",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        -3952,
        160
      ],
      "typeVersion": 1.6,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "fromJson",
        "binaryPropertyName": "json",
        "destinationKey": "***MASKED_SECRET***",
        "options": {
          "encoding": "utf8"
        }
      },
      "id": "55effa73-bfce-4414-8f00-72373a274737",
      "name": "Extract data from file",
      "type": "n8n-nodes-base.extractFromFile",
      "position": [
        -3616,
        -176
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "model": "gpt-5-mini",
        "options": {
          "maxTokens": "***MASKED_SECRET***",
          "maxRetries": 2
        }
      },
      "id": "0f9568e7-8996-4ab9-a2ca-614978aa4232",
      "name": "OpenAI Chat Model1",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        -3904,
        320
      ],
      "typeVersion": 1,
      "credentials": {
        "openAiApi": {
          "id": "LNm0mA6pNKzVyNdi",
          "name": "OpenAi datamobil_VX"
        }
      }
    },
    {
      "parameters": {
        "contextWindowLength": 3
      },
      "id": "26e7c66a-ef1d-4159-89bd-737ddce22968",
      "name": "Window Buffer Memory1",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "position": [
        -3776,
        368
      ],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ $('Extract SQL query').item.json.query }}",
        "options": {
          "connectionTimeout": 180
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2048,
        -384
      ],
      "id": "1a25e0a9-179d-4b4a-942d-6d0b70986d08",
      "name": "Execute a SQL query",
      "alwaysOutputData": true,
      "executeOnce": false,
      "credentials": {
        "postgres": {
          "id": "6iqsLXZTqf2rK4YA",
          "name": "Postgres account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b86f4807-aff3-42fb-a110-f43653368396",
              "name": "Solicitacao",
              "value": "={{ $json.chatInput }}",
              "type": "string"
            },
            {
              "id": "66447438-499c-4ab3-88ee-e20835aa7618",
              "name": "CodigoIManager",
              "value": "=testedev2",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4304,
        -176
      ],
      "id": "adf15a94-caaa-4c49-844a-cd8e4fcd8763",
      "name": "Setar informa√ß√µes de Par√¢metros"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f8f105fa-8e7c-4309-9cd9-9a5c987ed77f",
              "leftValue": "={{ $json.allowed }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2352,
        -288
      ],
      "id": "157bc116-95a4-4f1f-8db4-97a1986b7e7e",
      "name": "If1"
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items\n\nconst items = $input.all();\n\n// --- Utils ------------------------------------------------------------------\n\nfunction hasMeaningfulContent(o, depth = 0) {\n  if (o == null) return false;\n  if (typeof o !== 'object') return String(o).trim() !== '';\n  if (depth > 6) return true;\n  if (Array.isArray(o)) return o.some(v => hasMeaningfulContent(v, depth + 1));\n  const keys = Object.keys(o);\n  if (keys.length === 0) return false;\n  return keys.some(k => hasMeaningfulContent(o[k], depth + 1));\n}\n\nfunction collectErrorsDeep(obj, found = []) {\n  if (obj == null) return found;\n\n  const pushErr = (val) => {\n    if (val == null) return;\n    const msg = typeof val === 'object' ? JSON.stringify(val) : String(val);\n    if (msg.trim()) found.push(msg.trim());\n  };\n\n  if (Array.isArray(obj)) {\n    for (const v of obj) collectErrorsDeep(v, found);\n    return found;\n  }\n\n  if (typeof obj === 'object') {\n    for (const [k, v] of Object.entries(obj)) {\n      const lower = k.toLowerCase();\n      if (lower === 'erro' || lower === 'error') pushErr(v);\n      else if (lower === 'message' && typeof v === 'string') pushErr(v);\n      collectErrorsDeep(v, found);\n    }\n    return found;\n  }\n\n  return found;\n}\n\nfunction dedupStrings(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const s of arr) if (!seen.has(s)) { seen.add(s); out.push(s); }\n  return out;\n}\n\n// Prefer√™ncia do Luis: $json.message.content.data\nfunction extractUsefulPayload(j) {\n  if (Array.isArray(j?.message?.content?.data)) return j.message.content.data.slice();\n  if (Array.isArray(j?.data)) return j.data.slice();\n  if (hasMeaningfulContent(j)) return [j];\n  return [];\n}\n\nfunction normalizeList(list) {\n  return list\n    .map(x => (x?.json ?? x))\n    .filter(o => hasMeaningfulContent(o))\n    .map(o => (typeof o === 'object' ? o : { value: o }));\n}\n\n// Captura a query de forma resiliente (suporta Set, Function e mesmo payload)\nfunction safeGetQuery() {\n  // 1) Se a query veio nos itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const q = j.query ?? j.sql ?? j.consulta;\n    if (typeof q === 'string' && q.trim()) return q.trim();\n  }\n\n  // 2) Caso a query esteja em outro n√≥ do fluxo\n  try {\n    // Ajuste para o nome do n√≥ onde a SQL √© montada\n    const fromNode = $items('Extrair query', 0, 0);\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const q = j.query ?? j.sql ?? j.consulta;\n      if (typeof q === 'string' && q.trim()) return q.trim();\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null; // n√£o encontrada\n}\n\nfunction findUsageIn(obj) {\n  if (obj == null) return null;\n\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      const found = findUsageIn(el);\n      if (found) return found;\n    }\n    return null;\n  }\n\n  if (typeof obj === 'object') {\n    if (obj.usage && typeof obj.usage === 'object') {\n      const u = obj.usage;\n      const total =\n        typeof u.total_tokens === 'number'\n          ? u.total_tokens\n          : (typeof u.input_tokens === 'number' && typeof u.output_tokens === 'number'\n              ? u.input_tokens + u.output_tokens\n              : undefined);\n\n      return {\n        input_tokens: typeof u.input_tokens === 'number' ? u.input_tokens : undefined,\n        output_tokens: typeof u.output_tokens === 'number' ? u.output_tokens : undefined,\n        total_tokens: typeof total === 'number' ? total : undefined,\n      };\n    }\n\n    for (const v of Object.values(obj)) {\n      const found = findUsageIn(v);\n      if (found) return found;\n    }\n  }\n\n  return null;\n}\n\nfunction safeGetUsage() {\n  // 1) Tenta achar usage nos pr√≥prios itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const usage = findUsageIn(j);\n    if (usage) return usage;\n  }\n\n  // 2) Tenta achar usage no n√≥ \"GPT gerar query\"\n  try {\n    const fromNode = $items('GPT gerar query'); // <<--- AQUI entra o seu n√≥\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const usage = findUsageIn(j);\n      if (usage) return usage;\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null;\n}\n\n// --- Fluxo ------------------------------------------------------------------\n\n// Captura a query logo no in√≠cio, para us√°-la em QUALQUER retorno\nconst query = safeGetQuery();\n\nconsole.log(query)\n\n// 1) Sem entradas\nif (!items || items.length === 0) {\n  return [{ json: { Erro: 'N√£o foram encontrados dados para esta solicita√ß√£o', query, errors: ['Input vazio'] } }];\n}\n\n// 2) Procure erros em todo o payload bruto\nlet outerErrors = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  collectErrorsDeep(j, outerErrors);\n}\nouterErrors = dedupStrings(outerErrors);\n\n// 3) Se achou erro, retorna { Erro, query, errors }\nif (outerErrors.length > 0) {\n  return [{ json: { Erro: outerErrors[0], query, errors: outerErrors } }];\n}\n\n// 4) Extrair dados dos formatos suportados\nlet all = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  all.push(...extractUsefulPayload(j));\n}\n\n// 5) Fallback: cada item.json\nif (all.length === 0) {\n  all = items.map(i => i?.json ?? {});\n}\n\n// 6) Checar erros dentro da lista\nlet innerErrors = [];\ncollectErrorsDeep(all, innerErrors);\ninnerErrors = dedupStrings(innerErrors);\nif (innerErrors.length > 0) {\n  const errors = dedupStrings([...outerErrors, ...innerErrors]);\n  return [{ json: { Erro: innerErrors[0], query, errors } }];\n}\n\n// 7) Limpeza de dados\nconst rows = normalizeList(all);\n\n// 8) Sem dados ‚Üí erro padr√£o (com query e errors)\nif (rows.length === 0) {\n  return [{ json: { Erro: 'N√£o foram encontrados dados para esta solicita√ß√£o', query, errors: [] } }];\n}\n\nconst usage_gpt = safeGetUsage();\n\n// 9) OK: retorna SEMPRE { data, query, errors: [] }\nreturn [{ json: { data: rows, query, errors: [], tokensGeradorQuery: usage_gpt } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1808,
        -96
      ],
      "id": "6fb6cd10-e9a9-4b01-baa7-d777f152729b",
      "name": "Repassar dados"
    },
    {
      "parameters": {
        "jsCode": "// Entrada: { sql: \"SELECT ...\", userPrompt: \"...\" }  (ajuste nomes se preciso)\nlet sql = ($('Extract SQL query').first().json.query || \"\").trim();\n\n// 1) Remove coment√°rios (-- e /* */) e normaliza espa√ßos\nconst stripComments = s => {\n  // remove /* ... */ (multilinha)\n  s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, ' ');\n  // remove -- at√© o fim da linha\n  s = s.replace(/--.*$/gm, ' ');\n  return s;\n};\n\n/**\n * Sanitiza a SQL corrigindo problemas de sintaxe conhecidos\n * (COUNT() vazio e extract(year FROM ...)12 sem \"*\").\n *\n * A ideia √© semelhante ao stripComments: recebe a string e\n * devolve a string sanitizada de uma vez s√≥.\n */\nconst sanitizeSql = s => {\n  let out = s;\n\n  // 1) Corrige COUNT() ‚Üí COUNT(*)\n  //    - pega qualquer COUNT(   ) possivelmente com espa√ßos\n  out = out.replace(/COUNT\\s*\\(\\s*\\)/gi, 'COUNT(*)');\n\n  // 2) Corrige extract(year FROM algo)12 ‚Üí extract(year FROM algo)*12\n  //    - captura o conte√∫do dentro de year FROM ... )\n  //    - permite espa√ßos variados\n  out = out.replace(\n    /extract\\s*\\(\\s*year\\s+from\\s+([^)]+)\\)\\s*12/gi,\n    'extract(year FROM $1)*12'\n\n  );\n\n  return out;\n};\n\nconst cleaned = stripComments(sql).replace(/\\s+/g, ' ').trim();\n\n\nconst forbidden = /\\b(SOMENTE|INSERT|UPDATE|DELETE|MERGE|CREATE|ALTER|DROP|TRUNCATE|GRANT|REVOKE|COMMENT|VACUUM|COPY|REFRESH|CALL|DO|BEGIN|COMMIT|ROLLBACK|SET|LOCK|CLUSTER|REINDEX|DISCARD)\\b/i;\nif (forbidden.test(cleaned)) {\n  return [{ \n    allowed: false,\n    reason: \"Cont√©m comando proibido.\", \n    erro: `Somente SELECT √© permitido. N√£o posso executar DDL/DML.\n    Detalhes: ` + $input.first().json.output\n  }];\n}\n\nlet sqlSanitized = sanitizeSql(sql);\n\nconsole.log(sql)\n\nreturn [{allowed: true, sql: sqlSanitized }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2544,
        -288
      ],
      "id": "c3a779fd-1e65-43b9-bf4f-4e6a4071602d",
      "name": "Extrair query"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Run Once for Each Item\n// devolve UM item por entrada (sem colchetes)\nconst msg = $json.output; \nreturn {\n  json: {\n      erro:msg ?? \"Por favor, forne√ßa a consulta ou pergunta espec√≠fica que deseja realizar com base no esquema fornecido.\"\n  }\n};\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2496,
        -80
      ],
      "id": "6c1cc2ba-eb30-470b-b044-4a87d5653a41",
      "name": "Mensagem de query inv√°lida"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Run Once for Each Item\n/**\n const msg = \"Solicita√ß√£o cont√©m comando proibido, somente SELECT √© permitido. N√£o posso executar DDL/DML.\";\n */\nconst msg = $json.erro;\nreturn {\n  json: { erro: msg }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2080,
        -224
      ],
      "id": "8461ec06-6f36-456c-aaad-f26f6f2b3fe0",
      "name": "Mensagem de query Proibida"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item;\nconst j = item.json;\n\nconst configuracaoPorCliente = {\n  \"0001\": {\n    CNPJ: $input.first().json.CNPJ,\n    host: \"52.45.149.188\",\n    database: \"icommercial_faturamento_teste_luis\",\n    user: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"3738\": {\n    CNPJ: $input.first().json.CNPJ,\n    host: \"52.45.149.188\",\n    database: \"icommercial_faturamento_teste_luis\",\n    user: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"testedev2\": {\n    CNPJ: $input.first().json.CNPJ,\n    host: \"rabbitmq.icommercial002.inovamobil.com.br\",\n    database: \"icommercial_faturamento_testedev2\",\n    user: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n};\n\n// ==== OBRIGAT√ìRIO TER c√≥digo do IManager ====\nconst codigoIManager = (j.CodigoIManager ?? \"testedev2\");\nconst selected = configuracaoPorCliente[codigoIManager];\nif (!selected) {\n  throw new Error(\n    `Cliente ` + codigoIManager + ` n√£o informado, favor validar para utiliza√ß√£o do m√≥dulo.`\n  );\n}\n\n\nj.configuracao = {\n    host: selected.host,\n    database: selected.database,\n    user: selected.user,\n    password: selected.senha,\n    port: selected.porta,\n  };\n\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4064,
        -176
      ],
      "id": "c57e31f0-7867-4cc2-8eba-148d75fad635",
      "name": "Constantes"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/responses",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer ***MASKED_SECRET***"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-4.1-mini\",\n  \"temperature\": 0.2,\n  \"input\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Voc√™ √© um GERADOR DE SQL para PostgreSQL guiado por um JSON de esquema chamado SCHEMA. Seu objetivo √© produzir UMA √öNICA consulta SELECT 100% v√°lida, segura e fiel ao SCHEMA ‚Äî sem inventar nada.\\n\\n====================================================================\\nEXEMPLO GUIADO (N√ÉO REPITA NA RESPOSTA FINAL)\\nExemplo de uso correto para pedidos de 3 meses consecutivos:\\nPEDIDO_EXEMPLO:\\n\\\"Liste todas as liga√ß√µes que tiveram por 3 meses consecutivos no ano de 2025 a ocorr√™ncia LEITURA FORA DE FAIXA. Preciso que exiba o c√≥digo da liga√ß√£o, as refer√™ncias e o c√≥digo da ocorr√™ncia.\\\"\\n\\nRESPOSTA_EXEMPLO (SQL CORRETA):\\nWITH base AS (\\n  SELECT DISTINCT\\n    ul.\\\"UC_Lig_Id\\\",\\n    ul.\\\"UC_Leit_Ocorrencia_1\\\" AS ocorrencia_codigo,\\n    to_date(ul.\\\"UC_Leit_Mes_Ano\\\", 'MM/YYYY') AS ref_date\\n  FROM \\\"UC_Leitura\\\" ul\\n  JOIN \\\"Ocorrencias\\\" o\\n    ON o.\\\"Oco_Codigo\\\" = ul.\\\"UC_Leit_Ocorrencia_1\\\"\\n  WHERE\\n    o.\\\"Oco_Descricao\\\" ILIKE 'LEITURA FORA DE FAIXA'\\n    AND to_date(ul.\\\"UC_Leit_Mes_Ano\\\", 'MM/YYYY') >= DATE '2025-01-01'\\n    AND to_date(ul.\\\"UC_Leit_Mes_Ano\\\", 'MM/YYYY') < DATE '2026-01-01'\\n),\\nseq AS (\\n  SELECT\\n    b.\\\"UC_Lig_Id\\\",\\n    b.ocorrencia_codigo,\\n    b.ref_date,\\n    row_number() OVER (PARTITION BY b.\\\"UC_Lig_Id\\\" ORDER BY b.ref_date) AS rn,\\n    (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\\n      - row_number() OVER (PARTITION BY b.\\\"UC_Lig_Id\\\" ORDER BY b.ref_date) AS grp\\n  FROM base b\\n),\\nruns AS (\\n  SELECT\\n    \\\"UC_Lig_Id\\\",\\n    ocorrencia_codigo,\\n    grp,\\n    MIN(ref_date) AS ref1,\\n    COUNT(*) AS len\\n  FROM seq\\n  GROUP BY\\n    \\\"UC_Lig_Id\\\", ocorrencia_codigo, grp\\n  HAVING COUNT(*) >= 3\\n)\\nSELECT\\n  \\\"UC_Lig_Id\\\" AS \\\"Codigo_Ligacao\\\",\\n  to_char(ref1, 'MM/YYYY') AS \\\"Referencia_1\\\",\\n  to_char(ref1 + INTERVAL '1 month', 'MM/YYYY') AS \\\"Referencia_2\\\",\\n  to_char(ref1 + INTERVAL '2 month', 'MM/YYYY') AS \\\"Referencia_3\\\",\\n  ocorrencia_codigo AS \\\"Codigo_Ocorrencia\\\"\\nFROM runs\\nORDER BY \\\"Codigo_Ligacao\\\", \\\"Referencia_1\\\";\\n\\nFIM DO EXEMPLO.\\nUSE ESTE ESTILO COMO REFER√äNCIA.\\n====================================================================\\n\\nREGRAS PRIORIT√ÅRIAS (N√ÉO PODE DESCUMPRIR)\\n1) √â PROIBIDO usar COUNT(). SEMPRE use COUNT(*).\\n2) √â PROIBIDO escrever extract(year FROM algo)12. SEMPRE escreva extract(year FROM algo)*12.\\n3) Se o PEDIDO falar de ‚Äú3 meses consecutivos‚Äù, ‚Äú3 leituras seguidas‚Äù, ‚Äú3 faturas consecutivas‚Äù ou equivalente, voc√™ DEVE usar a f√≥rmula:\\n   (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\\n   - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\\n\\nSe qualquer uma dessas regras for violadas na sua consulta, voc√™ N√ÉO pode retorn√°-la.\\nEm vez disso, responda apenas:\\n\\\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\\\"\\n\\n====================================================================\\n\\nENTRADAS\\n- SCHEMA: objeto JSON (‚¶Éschema‚¶Ñ) com:\\n  ‚Ä¢ tabelas[*].nome\\n  ‚Ä¢ tabelas[*].colunas[*].nome, tipo, pk?, fk?\\n  ‚Ä¢ relacionamentos[] (from=\\\"A.x\\\", to=\\\"B.y\\\")\\n  ‚Ä¢ regras.periodo_MMYYYY, regras.streak_MMYYYY, regras.sql_lints,\\n    regras.required_patterns, regras.templates, regras.sql_rewrites (se existirem)\\n- PEDIDO: descri√ß√£o do que o usu√°rio quer consultar (‚¶Épedido‚¶Ñ).\\n\\n====================================================================\\nFONTES DE VERDADE\\n1) SCHEMA.tabelas/colunas\\n2) Relacionamentos expl√≠citos (FKs ou SCHEMA.relacionamentos)\\n3) ‚Äúregras.*‚Äù do SCHEMA (SE EXISTIREM) s√£o obrigat√≥rias.\\n\\nSe algo n√£o existir no SCHEMA, considere que N√ÉO existe: explique e N√ÉO gere SQL.\\n\\n====================================================================\\nREGRAS GERAIS\\n- Gere apenas SELECT (pode conter WITH). Nunca gere UPDATE, DELETE, INSERT, CREATE, DROP, etc.\\n- Use somente tabelas/colunas existentes no SCHEMA.\\n- JOINS s√≥ podem ser feitos quando existe um relacionamento v√°lido.\\n- Identificadores SEMPRE entre aspas duplas \\\"‚Ä¶\\\".\\n- Strings SEMPRE com aspas simples '‚Ä¶'.\\n- Nunca use SELECT *.\\n- COUNT(*) sempre que precisar contar.\\n- Nunca invente colunas ou tabelas.\\n\\n====================================================================\\nPER√çODO MM/YYYY (OBRIGAT√ìRIO se aplic√°vel)\\nSe existir SCHEMA.regras.periodo_MMYYYY para a coluna usada:\\n- Para filtrar por ano (ex.: 2025), use:\\n  to_date(coluna, 'MM/YYYY') >= DATE '{{ano}}-01-01'\\n  AND to_date(coluna, 'MM/YYYY') < DATE '{{ano_next}}-01-01'\\n\\n- √â PROIBIDO usar LIKE ou ILIKE em coluna MM/YYYY.\\n\\n====================================================================\\n3 MESES CONSECUTIVOS (streak_MMYYYY)\\nSempre que o PEDIDO mencionar:\\n- \\\"3 meses consecutivos\\\", \\\"3 leituras seguidas\\\",\\n- \\\"3 leituras consecutivas\\\", \\\"3 faturas seguidas\\\", etc.\\n\\nVoc√™ DEVE aplicar o m√©todo padr√£o baseado em row_number():\\nWITH base (...)\\nWITH seq (...)\\nWITH runs (...)\\nRespeitando:\\n- row_number() OVER (PARTITION BY pid ORDER BY ref_date)\\n- F√≥rmula obrigat√≥ria:\\n  (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\\n  - row_number() OVER (...)\\n\\n- HAVING COUNT(*) >= 3 (ou min_streak_default)\\n\\n====================================================================\\nUSO DE TEMPLATES DO SCHEMA\\nSe SCHEMA.regras.templates.tres_meses_consecutivos_generico existir:\\n- Voc√™ DEVE usar o template como base\\n- S√≥ pode alterar placeholders:\\n  {{padrao}}, {{ano}}, {{ano_next}}\\n\\n====================================================================\\nREGRAS DE REWRITES E REQUIRED PATTERNS\\nSe SCHEMA.regras.sql_rewrites existir:\\n- Aplique as substitui√ß√µes obrigat√≥rias\\nDepois valide required_patterns.\\n\\n====================================================================\\nCHECKLIST FINAL (AUTO-CHECAGEM)\\nAntes de retornar a query, confirme:\\n1) N√ÉO cont√©m COUNT()\\n2) N√ÉO cont√©m extract(year FROM ‚Ä¶)12\\n3) N√ÉO usa LIKE/ILIKE em colunas MM/YYYY\\n4) Se for streak:\\n   - row_number() obrigat√≥rio\\n   - f√≥rmula obrigat√≥ria\\n   - HAVING COUNT(*)\\n\\nSe falhar:  \\n\\\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\\\"\\n\\n====================================================================\\nREGRA ADICIONAL 1 (CLIENTE = LIGA√á√ÉO)\\nQuando o PEDIDO mencionar ‚Äúclientes‚Äù mas o SCHEMA n√£o tiver rela√ß√£o 1:1 entre cliente e liga√ß√£o:\\n- Considere UC_Lig_Id como identificador do ‚Äúcliente‚Äù.\\n- N√ÉO use Pes_Codigo, a menos que o pedido explicitamente pe√ßa dados da pessoa.\\n- Streaks, agrupamentos, contagens percentuais e indicadores devem ser feitos por liga√ß√£o.\\n\\n====================================================================\\nREGRA ADICIONAL 2 (CATEGORIA DA LIGA√á√ÉO)\\nQuando o PEDIDO envolver categoria da liga√ß√£o (Residencial, Comercial, Industrial, etc.):\\n- A categoria ‚Äúnormal‚Äù da liga√ß√£o usa SEMPRE o cat√°logo vCategoria (1=Residencial, 2=Comercial, 3=Industrial, 4=Publica, 5=Outros).\\n- Voc√™ pode obter essa categoria a partir de:\\n  ‚Ä¢ UC_Categoria.UC_Cat_Categoria ‚Üí vCategoria\\n  ‚Ä¢ UC_Leitura_Categoria.UC_LeitCat_Categoria ‚Üí vCategoria\\n- Use UC_Categoria quando a pergunta for sobre a categoria ATUAL da liga√ß√£o.\\n- Use UC_Leitura_Categoria quando a pergunta estiver ligada a leituras/faturas em um per√≠odo (ex.: ‚Äúem 2025‚Äù).\\n- Nunca use campos ligados a vTipoCategoriaRecalculo para responder perguntas sobre a categoria ‚Äúnormal‚Äù da liga√ß√£o.\\n\\n====================================================================\\nREGRA ADICIONAL 3 (LEITURAS ESTIMADAS)\\nQuando o PEDIDO falar de ‚Äúleituras estimadas‚Äù ou ‚Äúconsumo estimado‚Äù:\\n\\n- Uma leitura √© considerada ESTIMADA quando, para a liga√ß√£o (UC_Lig_Id) associada:\\n\\n  1) A liga√ß√£o N√ÉO possui hidr√¥metro ativo:\\n     N√ÉO deve existir registro em \\\"UC_Hidrometro\\\" com:\\n        ‚Ä¢ \\\"UC_Hidrometro\\\".\\\"UC_Lig_Id\\\" = \\\"UC_Leitura\\\".\\\"UC_Lig_Id\\\"\\n        ‚Ä¢ \\\"UC_Hidrometro\\\".\\\"UC_Hid_Ativo\\\" = TRUE\\n\\n  2) E existir registro em \\\"UC_Parametros\\\" com:\\n        ‚Ä¢ \\\"UC_Parametros\\\".\\\"UC_Lig_Id\\\" = \\\"UC_Leitura\\\".\\\"UC_Lig_Id\\\"\\n        ‚Ä¢ \\\"UC_Parametros\\\".\\\"UC_Par_Consumo_Estimado\\\" > 0\\n\\n- Para calcular quantidade ou taxa de leituras estimadas:\\n  ‚Ä¢ Trate TODAS as leituras da liga√ß√£o que satisfazem essas duas condi√ß√µes como ‚Äúestimadas‚Äù.\\n  ‚Ä¢ N√ÉO use apenas campos como \\\"UC_Leit_Leitura_Calculada\\\" para identificar estimadas.\\n\\n====================================================================\\nREGRA ADICIONAL 4 (C√ÅLCULO DE TAXA PERCENTUAL)\\nQuando precisar calcular uma taxa percentual (por exemplo, taxa de leituras estimadas por rota):\\n\\n- PRIMEIRO fa√ßa uma agrega√ß√£o em um n√≠vel (por exemplo, por rota), calculando:\\n  ‚Ä¢ COUNT(*)            AS total_registros\\n  ‚Ä¢ COUNT(*) FILTER (WHERE <condicao>) AS quantidade_com_condicao\\n\\n- S√ì DEPOIS, em um SELECT externo (ou CTE), calcule o percentual usando EXATAMENTE o padr√£o:\\n\\n  ROUND(\\n    CASE\\n      WHEN total_registros = 0 THEN 0\\n      ELSE quantidade_com_condicao::numeric / total_registros::numeric * 100\\n    END\\n  , 2) AS nome_da_taxa\\n\\n- Evite montar express√µes muito longas com CASE + COUNT(*) FILTER aninhados diretamente na mesma camada do GROUP BY, para reduzir erros de par√™nteses.\\n- Sempre que poss√≠vel, use:\\n  ‚Ä¢ um CTE de agrega√ß√£o (ex.: agg_por_rota)\\n  ‚Ä¢ e um SELECT final apenas para calcular a taxa a partir de total_registros e quantidade_com_condicao.\\n====================================================================\\nFORMATO DE RESPOSTA\\n- Se tudo estiver correto ‚Üí retorne somente a SQL final.\\n- Se violar qualquer regra ‚Üí retorne:\\n  \\\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\\\"\\n \\n\\n====================================================================\\nFORMATO DE RESPOSTA (OBRIGAT√ìRIO)\\n- Retorne SOMENTE a SQL pura.\\n- N√ÉO use markdown.\\n- N√ÉO use blocos ```sql ou ``` de nenhum tipo.\\n- N√ÉO coloque prefixos como \\\"SQL:\\\" ou \\\"Consulta:\\\".\\n- A resposta final deve ser EXATAMENTE uma string contendo apenas a query.\\n====================================================================\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.chatinput }}\"\n    }\n  ],\n  \"tools\": [\n    {\n      \"type\": \"file_search\",\n      \"vector_store_ids\": [\n        \"vs_691c57ff708881918d5932b6aaab6139\"\n      ]\n    }\n  ],\n  \"max_output_tokens\": 5000\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3168,
        -144
      ],
      "id": "d0ae6183-6799-442f-89d3-d36802d80547",
      "name": "GPT gerar query"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        0,
        -144
      ],
      "id": "0f60e74f-520c-4d7e-94f1-da58f22256c3",
      "name": "Unificar saidas"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "5787e004-2bc5-4530-8e20-cea5b52f05ef",
              "leftValue": "={{ $json.Erro.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        176,
        -144
      ],
      "id": "9cbf46fc-9702-4595-9ce3-09dae60af013",
      "name": "Gerou algum erro ?1"
    },
    {
      "parameters": {
        "jsCode": "// === 1. CAPTURA DO BRUTO (CAMPO \"analise\") ===\nlet raw =\n  $json.analise\n  ?? $json.output\n  ?? $json.text\n  ?? $json.response\n  ?? \"\";\n\n// captura o bloco de uso do modelo, se existir\nconst usageRaw = $json.usage ?? {};\n\n// normaliza para o formato usage_GTP_Analista\nconst usage_GTP_Analista = {\n  input_tokens: usageRaw.input_tokens ?? null,\n  output_tokens: usageRaw.output_tokens ?? null,\n  total_tokens: usageRaw.total_tokens ?? null,\n};\n\n// Se j√° vier objeto, √≥timo, n√£o precisa parsear string\nlet obj;\nif (raw && typeof raw === \"object\") {\n  obj = raw;\n} else {\n  // for√ßa string\n  raw = String(raw).trim()\n    // remove ```json ... ``` se vier\n    .replace(/^```(?:json)?\\s*/i, \"\")\n    .replace(/\\s*```$/i, \"\");\n\n  // desserializa caso seja string JSON dentro de aspas\n  if (\n    (raw.startsWith('\"') && raw.endsWith('\"')) ||\n    (raw.startsWith(\"'\") && raw.endsWith(\"'\"))\n  ) {\n    try { raw = JSON.parse(raw); } catch {}\n  }\n\n  // extrai a partir do primeiro \"{\", mesmo que n√£o tenha \"}\" depois\n  if (typeof raw === \"string\") {\n    const firstBrace = raw.indexOf(\"{\");\n    if (firstBrace >= 0) {\n      raw = raw.slice(firstBrace);\n    }\n  }\n\n  // === 2. PARSE COM HEUR√çSTICA REFOR√áADA ===\n  function tryParseWithBraceHeuristic(str) {\n    if (typeof str !== \"string\") return str;\n\n    let cleaned = str.trim();\n\n    // normaliza quebras de linha Windows\n    cleaned = cleaned.replace(/\\r\\n/g, \"\\n\");\n\n    // normalizar n√∫meros com separador de milhar tipo \": 2,570\"\n    cleaned = cleaned.replace(\n      /(:\\s*)(-?\\d{1,3}),(\\d{3})(\\s*[,\\}])/g,\n      (_, p, a, b, s) => `${p}${a}${b}${s}`\n    );\n\n    // remove v√≠rgula sobrando antes de } ou ]\n    cleaned = cleaned.replace(/,\\s*([}\\]])/g, \"$1\");\n\n    // 1¬™ tentativa: JSON.parse direto\n    try {\n      return JSON.parse(cleaned);\n    } catch (e1) {\n      // 2¬™ tentativa: procurar fechamento de objeto por chaves balanceadas\n      let depth = 0;\n      let inString = false;\n      let escape = false;\n      let lastCompleteIndex = -1;\n      let lastTopCommaIndex = -1; // v√≠rgula em profundidade 1\n\n      for (let i = 0; i < cleaned.length; i++) {\n        const ch = cleaned[i];\n\n        if (escape) {\n          escape = false;\n          continue;\n        }\n        if (ch === \"\\\\\") {\n          escape = true;\n          continue;\n        }\n        if (ch === '\"' && !escape) {\n          inString = !inString;\n          continue;\n        }\n        if (inString) continue;\n\n        if (ch === \"{\") {\n          depth++;\n        } else if (ch === \"}\") {\n          depth--;\n          if (depth === 0) {\n            lastCompleteIndex = i;\n          }\n        } else if (ch === \",\" && depth === 1) {\n          // v√≠rgula logo ap√≥s um campo completo no objeto raiz\n          lastTopCommaIndex = i;\n        }\n      }\n\n      // Caso 1: encontramos um objeto completo dentro da string\n      if (lastCompleteIndex > -1) {\n        let candidate = cleaned.slice(0, lastCompleteIndex + 1);\n        candidate = candidate.replace(/,\\s*([}\\]])/g, \"$1\");\n        return JSON.parse(candidate);\n      }\n\n      // Caso 2: objeto nunca fecha (JSON truncado), mas temos\n      // pelo menos uma v√≠rgula em profundidade 1 ‚Üí podemos cortar o √∫ltimo campo quebrado\n      if (lastTopCommaIndex > -1) {\n        let candidate = cleaned.slice(0, lastTopCommaIndex); // corta na v√≠rgula\n        candidate = candidate.replace(/[\\s,\\n\\r]+$/g, \"\");  // limpa sobra no final\n        candidate = candidate + \"\\n}\";                     // fecha o objeto\n\n        candidate = candidate.replace(/,\\s*([}\\]])/g, \"$1\");\n\n        return JSON.parse(candidate);\n      }\n\n      // Se nada disso funcionar, real joga o erro\n      throw e1;\n    }\n  }\n\n  let parsed;\n  try {\n    parsed = tryParseWithBraceHeuristic(raw);\n  } catch (eFinal) {\n    // fallback final: em vez de estourar tudo, devolve bruto dentro de Diagn√≥sticoTextoBruto\n    return [{\n      json: {\n        Diagn√≥stico: {\n          erro: \"Falha ao parsear JSON (mesmo com heur√≠stica).\",\n          detalhe: String(eFinal),\n          amostra: String(raw).slice(0, 500)\n        },\n        usage_GTP_Analista\n      }\n    }];\n  }\n\n  obj = parsed;\n}\n\n// === 3. MAPA DE RENOMEA√á√ÉO (NOVO) ===\nconst map = {\n  // contexto\n  \"üß≠contexto\": \"üß≠ contexto\",\n  \"contexto\": \"üß≠ contexto\",\n\n  // indicadores\n  \"üìàindicadores\": \"üìà indicadores\",\n  \"indicadores\": \"üìà indicadores\",\n\n  // an√°lise\n  \"üß†an√°lise\": \"üß† an√°lise\",\n  \"analise\": \"üß† an√°lise\",\n  \"an√°lise\": \"üß† an√°lise\",\n\n  // a√ß√µes\n  \"‚öôÔ∏èa√ß√µes\": \"‚öôÔ∏è a√ß√µes\",\n  \"acoes\": \"‚öôÔ∏è a√ß√µes\",\n  \"a√ß√µes\": \"‚öôÔ∏è a√ß√µes\",\n\n  // resumo consultivo\n  \"resumo_consultivo\": \"üß∑ resumo_consultivo\",\n  \"üß∑resumo_consultivo\": \"üß∑ resumo_consultivo\"\n};\n\nfunction renameKeys(o) {\n  if (o == null || typeof o !== \"object\") return o;\n\n  const out = {};\n\n  for (const [k, v] of Object.entries(o)) {\n    const nk = map[k] ?? k;\n    out[nk] = v;\n  }\n\n  return out;\n}\n\nconst withEmoji = renameKeys(obj);\n\n// === 4. RETORNO FINAL ===\nreturn [{\n  json: {\n    Diagn√≥stico: withEmoji,\n    usage_GTP_Analista\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -192,
        32
      ],
      "id": "6f02a031-40ce-4c25-8340-e7766c09e624",
      "name": "Formatar retorno GPT"
    },
    {
      "parameters": {
        "jsCode": "// Entrada vinda do n√≥ anterior (Gerar Resumo para BILL)\n\n// pedido do cliente\nconst pedido =\n  $json.envelope?.pedido_cliente\n  ?? $json.pedido_cliente\n  ?? $json.envelope?.pedido\n  ?? \"\";\n\n// dados reais do dataset (resultado.data)\nconst data =\n  $json.envelope?.resultado?.data\n  ?? $json.data\n  ?? [];\n\n// PROMPT BILL ‚Äì VERS√ÉO COMPLETA REESTRUTURADA\nconst promptBill = `\nVoc√™ √© BILL, consultor t√©cnico e estrat√©gico especializado em saneamento b√°sico. Sua miss√£o √© analisar o pedido_cliente e o data, produzindo um diagn√≥stico consultivo em JSON v√°lido, com rigor t√©cnico, sem texto fora do JSON. Use somente os dados de data para c√°lculos e an√°lises. N√£o presuma vari√°veis ausentes no dataset. Adapte sempre a an√°lise ao tema do pedido.\n\nCaso haja apenas 1 a 3 valores num√©ricos relevantes, seja extremamente direto. Se houver mais de 3 valores, produza an√°lise mais detalhada e interpretativa.\n\nVoc√™ DEVE retornar apenas um √∫nico objeto JSON, seguindo exatamente a estrutura abaixo, sem alterar nomes de campos, sem criar campos extras, sem pluralizar ou traduzir chaves:\n\n‚¶É\n \"üß≠ contexto\": \"Compare o desempenho local com benchmarks nacionais, metas regulat√≥rias e boas pr√°ticas do setor. Utilize refer√™ncias do SNIS 2023 (2025), ANA, Trata Brasil, ONDAS, ABCON/SINDCON, IAS e ag√™ncias reguladoras estaduais. Explique de forma objetiva onde os resultados se distanciam ou se aproximam dos padr√µes de refer√™ncia, sempre coerente com o tema do pedido_cliente.\",\n \n \"üìà indicadores\": \"Reconhe√ßa automaticamente se o dataset √© linha √∫nica com colunas agregadas ou m√∫ltiplos registros. Use todas as colunas num√©ricas como indicadores v√°lidos. Em m√∫ltiplas linhas, calcule totais, m√©dias, propor√ß√µes e percentuais diretamente dos valores existentes. Identifique varia√ß√µes temporais quando houver sufixos como '_MM_AAAA'. Liste m√©tricas derivadas dos valores existentes ‚Äî somat√≥rios, m√©dias, percentuais, varia√ß√µes entre per√≠odos, indicadores por grupo, distribui√ß√£o de ocorr√™ncia, concentra√ß√£o e diferen√ßas entre categorias/rotas/leituristas quando existirem ‚Äî sempre usando exatamente os nomes dos campos do dataset. Nunca repita n√∫meros de forma divergente em outra se√ß√£o. Resuma esses mesmos n√∫meros com duas casas decimais quando aplic√°vel, incluindo percentuais com s√≠mbolo % e valores financeiros com prefixo R$. Nunca crie novos n√∫meros; apenas reorganize e combine valores j√° presentes. Se alguma consolida√ß√£o for insegura, declare isso explicitamente. Sempre que houver distribui√ß√£o por categorias, faixas de consumo, tipos de ocorr√™ncia, rotas, bairros ou grupos similares, apresente cada item em linha separada, iniciando com '‚Ä¢'. Nunca apresente listas desse tipo em linha √∫nica.\",\n\n \"üß† an√°lise\": \"Explique o que os valores de data significam em termos de comportamento: melhora, piora, estabilidade, concentra√ß√£o de problemas, varia√ß√µes entre grupos ou per√≠odos, faixas de criticidade (at√© 10% baixa, 10‚Äì20% moderada, 20‚Äì30% elevada, >30% cr√≠tica). Relacione os achados com fen√¥menos t√≠picos do saneamento: micromedi√ß√£o, perdas comerciais, tarifa m√≠nima, ocorr√™ncias recorrentes, baixa cobertura de hidr√¥metros, inconsist√™ncias de leitura, concentra√ß√£o de consumo, falhas de processo, problemas cadastrais e efeitos operacionais. Traga hip√≥teses t√©cnicas plaus√≠veis coerentes com o setor, sem inventar n√∫meros. Compare grupos quando existirem, indicando quem est√° melhor ou pior e qual a diferen√ßa aproximada, sempre baseada nos valores reais do dataset.\",\n\n \"‚öôÔ∏è a√ß√µes\": [\"Descreva a√ß√µes pr√°ticas e decis√µes futuras baseadas nos valores presentes em data: auditorias, inspe√ß√µes em campo, ajustes operacionais, substitui√ß√£o ou instala√ß√£o de hidr√¥metros, revis√£o cadastral, refinamento de rotas de leitura, interven√ß√µes para reduzir reincid√™ncias, valida√ß√µes adicionais de dados e defini√ß√£o de pr√≥ximos passos para continuidade da an√°lise. N√£o mencione prazos.\"],\n\n \"üß∑ resumo_consultivo\": \"Forne√ßa uma conclus√£o executiva (at√© 7 linhas) destacando evid√™ncias num√©ricas-chave, gravidade expressa em %, potenciais impactos em R$, prioridades e o valor estrat√©gico de agir ‚Äî em efici√™ncia, perdas, faturamento, qualidade de leitura e sustentabilidade econ√¥mica.\"\n‚¶Ñ\n\nRegras num√©ricas e de consist√™ncia:\n- Nunca invente valores; apenas use os existentes em data.\n- Percentuais sempre com s√≠mbolo %.\n- Valores financeiros sempre com R$.\n- Nunca use separador de milhar no JSON (2570).\n- N√£o contradiga n√∫meros entre se√ß√µes.\n- Se uma consolida√ß√£o for insegura, declare isso.\n\nCASO SEM DADOS:\n‚¶É\n \"üß≠ contexto\": \"‚Äî\",\n \"üìà indicadores\": \"‚Äî\",\n \"üß† an√°lise\": \"‚Äî\",\n \"‚öôÔ∏è a√ß√µes\": [],\n \"üß∑ resumo_consultivo\": \"N√£o h√° dados suficientes para an√°lise.\"\n‚¶Ñ`;\n\n// Compacta entrada do usu√°rio em um √∫nico JSON\nconst userPayload = {\n  pedido_cliente: pedido,\n  data\n};\n\n\n// Body da chamada para /v1/responses\nconst openaiBody = {\n  model: \"gpt-4.1-mini\",\n  temperature: 0.2,\n  max_output_tokens: 1000,\n\n  text: {\n    format: {\n      type: \"json_object\"\n    }\n  },\n\n  input: [\n    {\n      role: \"system\",\n      content: [\n        {\n          type: \"input_text\",\n          text: promptBill\n        }\n      ]\n    },\n    {\n      role: \"user\",\n      content: [\n        {\n          type: \"input_text\",\n          text: JSON.stringify(userPayload)\n        }\n      ]\n    }\n  ]\n};\n\nreturn [\n  {\n    json: {\n      openaiBody\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1024,
        32
      ],
      "id": "d3f2c1d6-a893-47ec-a114-e2d3b3085f3a",
      "name": "Montar Prompt an√°lise"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ebbe194a-4b8b-44c9-ac19-03cf69d353bf",
              "name": "analise",
              "type": "string",
              "value": "={{ \n  ($json.output || [])\n    .find(o => o.type === 'message')\n    .content\n    .find(c => c.type === 'output_text')\n    .text \n}}"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "872ee13a-8795-45c3-abf7-7e7935367c34",
      "name": "Formatar retorno GTP analista",
      "type": "n8n-nodes-base.set",
      "position": [
        -400,
        32
      ],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/responses",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer ***MASKED_SECRET***"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={{ JSON.stringify($json.openaiBody) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -704,
        32
      ],
      "id": "355741e9-ca37-4010-ab09-da4687efbbd6",
      "name": "GPT analisar dados",
      "retryOnFail": true,
      "waitBetweenTries": 2000
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "5787e004-2bc5-4530-8e20-cea5b52f05ef",
              "leftValue": "={{ !!(\n  $json.Erro\n    ? (Array.isArray($json.Erro)\n        ? $json.Erro.length > 0\n        : String($json.Erro).trim() !== '')\n    : false\n) }}",
              "rightValue": 0,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1584,
        -32
      ],
      "id": "685040bd-f797-4e07-9cd8-a81002b24ca8",
      "name": "Gerou algum erro ?"
    },
    {
      "parameters": {
        "jsCode": "// Agora o Merge j√° trouxe os dois lados num √∫nico item (json √∫nico)\nconst M = $json || {};\n\nconst pedido_cliente =$('Combine schema data and chat input').first().json.chatinput;\n  \nconst data =\n  M.data ??\n  M.envelope?.resultado?.data ??\n  null;\n\nconst query =\n  M.query ??\n  M.envelope?.resultado?.query ??\n  null;\n\n// Erros podem ter vindo de Repassar dados\nconst erro  = M.erro ?? M.error ?? null;\nconst erros = Array.isArray(M.Erros) ? M.Erros\n           : Array.isArray(M.erros) ? M.erros\n           : Array.isArray(M.errors) ? M.errors\n           : [];\n\n// A an√°lise pode ter vindo do Analista em v√°rias chaves\nconst diagnostico =$input.first().json[\"Diagn√≥stico\"];\n\nconsole.log(\"input\", $input.first())\n\nconst usage_GPT_Query = $input.first().json.usage_GPT_Query;\nconst usage_GPT_Analista = $input.first().json.usage_GTP_Analista;\n\nconst hasError = !!erro || (Array.isArray(erros) && erros.length > 0);\n\nreturn [{\n  json: {\n    pedido_cliente,\n    data,\n    query,\n    erro,\n    erros,\n    diagnostico: hasError ? null : diagnostico,\n    usage_GPT_Query,\n    usage_GPT_Analista\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        -48
      ],
      "id": "1397eb18-bef9-434c-845d-56fb0aa4801c",
      "name": "Unificar Resultado",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Captura o node \"Combine schema data and chat input\"\nconst combineNode = $('Combine schema data and chat input').first();\nconst pedido = combineNode?.json?.chatinput || '';\n\n// Captura o dataset atual\nconst src = $json.envelope ?? $json;\nconst dataIn = Array.isArray(src?.resultado?.data)\n  ? src.resultado.data\n  : Array.isArray(src?.data)\n  ? src.data\n  : [];\n\n// Normaliza chaves e converte valores num√©ricos\nconst normalizeKey = (k) =>\n  k\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, '_')\n    .replace(/[^\\w]/g, '_')\n    .replace(/_+/g, '_')\n    .replace(/^_|_$/g, '')\n    .toLowerCase();\n\nconst toNumber = (v) =>\n  typeof v === 'string' && /^\\s*\\d+(?:[.,]\\d+)?\\s*$/.test(v)\n    ? Number(v.replace(',', '.'))\n    : v;\n\n// üî• VERS√ÉO CORRIGIDA ‚Äî sem duplicar TotalLeituras/totalleituras\nconst dataNorm = (dataIn || []).map((row) => {\n  const out = {};\n  for (const [k, v] of Object.entries(row)) {\n    const nk = normalizeKey(k);\n    const nv = toNumber(v);\n\n    // Apenas a chave normalizada\n    out[nk] = nv;\n  }\n  return out;\n});\n\n// Monta o envelope final para o BILL\nreturn [\n  {\n    json: {\n      envelope: {\n        pedido_cliente: pedido || src.pedido_cliente || '‚Äî',\n        resultado: {\n          data: dataNorm,\n          query: src?.resultado?.query || src?.query || '',\n        },\n        metadados: src.metadados || {\n          origem: 'n8n',\n          unidade: 'clientes',\n          moeda: 'BRL',\n        },\n      },\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1344,
        32
      ],
      "id": "d0c94e8b-f4fa-4d43-a40b-c89fea1c56fa",
      "name": "Gerar envelope de dados e solicita√ß√£o"
    },
    {
      "parameters": {
        "jsCode": "// ==============================\n// 1. ENTRADAS B√ÅSICAS\n// ==============================\nconst pedido = $json.pedido_cliente;\nconst data = $json.data || [];\nconst query = $json.query || \"\";\n\n// diagnostico pode vir como \"diagnostico\" ou \"Diagn√≥stico\"\nconst d = $json.Diagn√≥stico || $json.diagnostico || {};\n\n\n// ==============================\n// 2. HELPERS GERAIS\n// ==============================\nfunction toArraySafe(val) {\n  if (val == null) return [];\n  if (Array.isArray(val)) return val;\n  if (typeof val === \"object\") return [JSON.stringify(val, null, 2)];\n  return [String(val)];\n}\n\nfunction toTextSafe(val, fallback = \"‚Äî\") {\n  if (val == null) return fallback;\n  if (typeof val === \"string\") return val;\n  if (typeof val === \"number\" || typeof val === \"boolean\") return String(val);\n  return JSON.stringify(val, null, 2);\n}\n\n\n// ==============================\n// 3. FORMATA√á√ÉO NUM√âRICA POR CONTEXTO\n// ==============================\nfunction formatMoneyBr(num) {\n  if (num == null || isNaN(num)) return \"R$ 0,00\";\n  return (\n    \"R$ \" +\n    Number(num).toLocaleString(\"pt-BR\", {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    })\n  );\n}\n\nfunction formatPercentBr(num) {\n  if (num == null || isNaN(num)) return \"0%\";\n  return (\n    Number(num).toLocaleString(\"pt-BR\", {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    }) + \"%\"\n  );\n}\n\nfunction formatIntegerBr(num) {\n  if (num == null || isNaN(num)) return \"0\";\n  return Number(num).toLocaleString(\"pt-BR\", {\n    maximumFractionDigits: 0,\n  });\n}\n\nfunction formatNumberWithContext(chave, parentKey, value) {\n  const k = (chave || \"\").toLowerCase();\n  const p = (parentKey || \"\").toLowerCase();\n\n  if (\n    k.includes(\"valor\") ||\n    k.includes(\"fatura\") ||\n    k.includes(\"faturado\") ||\n    k.includes(\"receita\") ||\n    p.includes(\"valor_faturado\") ||\n    p.includes(\"faturado\") ||\n    p.includes(\"faturas\")\n  ) {\n    return formatMoneyBr(value);\n  }\n\n  if (\n    k.includes(\"percent\") ||\n    k.includes(\"perc\") ||\n    k.endsWith(\"_pct\") ||\n    k.endsWith(\"_percentual\") ||\n    k.includes(\"taxa\") ||\n    k.includes(\"indice\") ||\n    k.includes(\"√≠ndice\")\n  ) {\n    return formatPercentBr(value);\n  }\n\n  if (\n    k.includes(\"consumo\") ||\n    k.includes(\"volume\") ||\n    k.includes(\"m3\") ||\n    k.includes(\"m¬≥\")\n  ) {\n    return `${formatIntegerBr(value)} m¬≥`;\n  }\n\n  if (\n    k.includes(\"leitura\") ||\n    k.includes(\"leituras\") ||\n    k.includes(\"qtd\") ||\n    k.includes(\"quantidade\") ||\n    k.includes(\"total\") ||\n    k.includes(\"economias\") ||\n    k.includes(\"registros\")\n  ) {\n    return formatIntegerBr(value);\n  }\n\n  return Number(value).toLocaleString(\"pt-BR\", {\n    maximumFractionDigits: 2,\n  });\n}\n\n\n// ==============================\n// 4. AMOSTRA DE DADOS (JSON COMPLETO)\n// ==============================\nlet amostraDados;\nif (data.length === 0) {\n  amostraDados = \"Nenhum registro retornado.\";\n} else {\n  amostraDados = JSON.stringify(data, null, 2);\n}\n\n\n// ==============================\n// 5. ACESSO AOS BLOCOS DO DIAGN√ìSTICO\n// ==============================\nconst contexto =\n  d[\"üß≠ contexto\"] ||\n  d[\"contexto\"] ||\n  \"‚Äî\";\n\nconst indicadoresRaw = d[\"üìà indicadores\"] || d[\"indicadores\"] || \"‚Äî\";\n\nlet indicadoresDescricao = \"‚Äî\";\nlet valores = {};\n\nif (typeof indicadoresRaw === \"string\") {\n  indicadoresDescricao = indicadoresRaw;\n} else if (indicadoresRaw && typeof indicadoresRaw === \"object\") {\n  indicadoresDescricao = toTextSafe(\n    indicadoresRaw[\"üìù descri√ß√£o\"] ||\n      indicadoresRaw[\"üìù descricao\"] ||\n      indicadoresRaw.descricao\n  );\n  valores =\n    indicadoresRaw[\"üî¢ valores\"] ||\n    indicadoresRaw[\"valores\"] ||\n    {};\n}\n\n// valor final de indicadores\nlet indicadores = toTextSafe(indicadoresDescricao);\n\n\n// üîß **AJUSTE CR√çTICO: transformar bullets \"‚Ä¢\" em lista markdown \"-\"**\nif (typeof indicadores === \"string\" && indicadores.includes(\"‚Ä¢\")) {\n  const partes = indicadores.split(\"‚Ä¢\");\n\n  const cabecalho = partes.shift().trimEnd();\n\n  const linhasBullets = partes\n    .map(p => p.trim())\n    .filter(p => p.length > 0)\n    .map(p => \"- \" + p)\n    .join(\"\\n\");\n\n  if (cabecalho && linhasBullets) {\n    indicadores = cabecalho + \"\\n\" + linhasBullets;\n  } else if (!cabecalho && linhasBullets) {\n    indicadores = linhasBullets;\n  } else {\n    indicadores = cabecalho || indicadores;\n  }\n}\n\n\n// ==============================\n// 5.1 CAPTURA ROBUSTA DA AN√ÅLISE\n// ==============================\nfunction extrairAnaliseInterpretativa(...objs) {\n  for (const obj of objs) {\n    if (!obj || typeof obj !== \"object\") continue;\n    for (const [k, v] of Object.entries(obj)) {\n      const kl = k.toLowerCase();\n      if (\n        kl.includes(\"an√°lise_interpretativa\") ||\n        kl.includes(\"analise_interpretativa\")\n      ) {\n        if (typeof v === \"string\") return v;\n      }\n    }\n  }\n  return \"-\";\n}\n\nconst analise =\n  d[\"üß† an√°lise\"] ||\n  d[\"üß† analise\"] ||\n  d[\"analise\"] ||\n  d[\"an√°lise\"] ||\n  extrairAnaliseInterpretativa(d, valores) ||\n  \"-\";\n\nconst acoes = toArraySafe(d[\"‚öôÔ∏è a√ß√µes\"] || d[\"acoes\"] || d[\"a√ß√µes\"]);\n\nconst resumoConsultivo = toTextSafe(\n  d[\"üß∑ resumo_consultivo\"] || d[\"resumo_consultivo\"]\n);\n\n\n// ==============================\n// 7. TEXTO FINAL\n// ==============================\nconst texto =\n  `üß≠ CONTEXTO\\n\\n` +\n  `${toTextSafe(contexto)}\\n\\n` +\n  `üìà INDICADORES\\n\\n` +\n  `${indicadores}\\n\\n` +\n  `üìã AN√ÅLISE\\n\\n` +\n  `${toTextSafe(analise)}\\n\\n` +\n  `‚öôÔ∏è A√á√ïES\\n\\n` +\n  `${\n    acoes.length\n      ? acoes.map((s) => \"- \" + s).join(\"\\n\")\n      : \"‚Äî\"\n  }\\n\\n` +\n  `üß∑ RESUMO CONSULTIVO\\n\\n` +\n  `${resumoConsultivo}`;\n\n\n// ==============================\n// 8. RETORNO PARA O CHAT\n// ==============================\n\nreturn [\n  {\n    json: {\n      data,\n      analise: texto,\n      query: $json.query,\n      erro: $json.erro,\n      erros: $json.erros,\n      usage_GPT: $json.usage_GPT_Query,\n      usage_GPT_Diagnostico: $json.usage_GPT_Analista\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        -48
      ],
      "id": "6195d476-8e88-4793-bf7a-efaa7affe135",
      "name": "Formatar visualiza√ß√£o",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "path": "analyticsIAAnalise",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "data",
          "responseHeaders": {
            "entries": [
              {
                "name": "Solicitacao"
              },
              {
                "name": "CNPJ"
              },
              {
                "name": "CodigoManager"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -4592,
        -176
      ],
      "id": "4e6f0db3-4d67-417f-96be-a8cd296786ed",
      "name": "Entrada",
      "webhookId": "4d110ba1-2fc6-4d65-810a-362b2d518210"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        976,
        -48
      ],
      "id": "ea24a73e-0486-483c-8d1e-54324c5214eb",
      "name": "Respond to Webhook"
    }
  ],
  "connections": {
    "Download file": {
      "main": [
        [
          {
            "node": "Extract data from file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if query exists": {
      "main": [
        [
          {
            "node": "Extrair query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mensagem de query inv√°lida",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract SQL query": {
      "main": [
        [
          {
            "node": "Check if query exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine schema data and chat input": {
      "main": [
        [
          {
            "node": "GPT gerar query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        []
      ]
    },
    "Extract data from file": {
      "main": [
        [
          {
            "node": "Combine schema data and chat input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Window Buffer Memory1": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setar informa√ß√µes de Par√¢metros": {
      "main": [
        [
          {
            "node": "Constantes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mensagem de query Proibida",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repassar dados": {
      "main": [
        [
          {
            "node": "Gerou algum erro ?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Unificar saidas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extrair query": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mensagem de query inv√°lida": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mensagem de query Proibida": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Constantes": {
      "main": [
        [
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT gerar query": {
      "main": [
        [
          {
            "node": "Extract SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unificar saidas": {
      "main": [
        [
          {
            "node": "Gerou algum erro ?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gerou algum erro ?1": {
      "main": [
        [],
        [
          {
            "node": "Unificar Resultado",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatar retorno GPT": {
      "main": [
        [
          {
            "node": "Unificar saidas",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Montar Prompt an√°lise": {
      "main": [
        [
          {
            "node": "GPT analisar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatar retorno GTP analista": {
      "main": [
        [
          {
            "node": "Formatar retorno GPT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT analisar dados": {
      "main": [
        [
          {
            "node": "Formatar retorno GTP analista",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gerou algum erro ?": {
      "main": [
        [
          {
            "node": "Unificar saidas",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "Gerar envelope de dados e solicita√ß√£o",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unificar Resultado": {
      "main": [
        [
          {
            "node": "Formatar visualiza√ß√£o",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gerar envelope de dados e solicita√ß√£o": {
      "main": [
        [
          {
            "node": "Montar Prompt an√°lise",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Formatar visualiza√ß√£o": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entrada": {
      "main": [
        [
          {
            "node": "Setar informa√ß√µes de Par√¢metros",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "0103c419-98d2-4500-9c62-5740e5e45180",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-12-24T13:52:39.057Z",
      "createdAt": "2025-12-24T13:52:39.057Z",
      "role": "workflow:owner",
      "workflowId": "ScfkSb8eRAojeAcR",
      "projectId": "bDUBly1zU3yziLIn"
    }
  ],
  "tags": []
}