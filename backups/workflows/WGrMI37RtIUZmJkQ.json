{
  "createdAt": "2025-09-19T11:54:07.405Z",
  "updatedAt": "2025-11-12T19:13:21.000Z",
  "id": "WGrMI37RtIUZmJkQ",
  "name": "Datamobil - VX Embedded - Homologação",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "1Me1e3qR3ZqwJO6TQvowfBmmaocjsp3-b",
          "mode": "list",
          "cachedResultName": "SFC_WEB_Completo.json",
          "cachedResultUrl": "https://drive.google.com/file/d/1Me1e3qR3ZqwJO6TQvowfBmmaocjsp3-b/view?usp=drivesdk"
        },
        "options": {
          "binaryPropertyName": "json"
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -3696,
        -80
      ],
      "id": "d0c46f27-e30f-4e76-a8f1-772d63fc9e9d",
      "name": "Download file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "A7dItjE7OWcTVPSQ",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "5f3b3c30-78e9-4ed0-b520-9153664540ec",
              "leftValue": "={{ $json.query }}",
              "rightValue": "SELECT",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "fbe5a055-a1ca-4f08-8870-1ce39565c19f",
      "name": "Check if query exists",
      "type": "n8n-nodes-base.if",
      "position": [
        -2608,
        -64
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ebbe194a-4b8b-44c9-ac19-03cf69d353bf",
              "name": "query",
              "type": "string",
              "value": "={{ ($json.output) }}"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "d02d6529-8e9c-4f6d-af69-b3d4dcc311fb",
      "name": "Extract SQL query",
      "type": "n8n-nodes-base.set",
      "position": [
        -2768,
        -64
      ],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "42abd24e-419a-47d6-bc8b-7146dd0b8314",
              "name": "sessionId",
              "type": "string",
              "value": "={{ $('Entrada').item.json.query.CNPJ }}"
            },
            {
              "id": "f78c57d9-df13-43c7-89a7-5387e528107e",
              "name": "chatinput",
              "type": "string",
              "value": "={{ $('Entrada').item.json.query.Solicitacao }}"
            },
            {
              "id": "e42b39eb-dfbd-48d9-94ed-d658bdd41454",
              "name": "schema",
              "type": "string",
              "value": "={{ $json.json }}"
            }
          ]
        },
        "options": {}
      },
      "id": "5211fc41-8c63-42ec-8d86-3c1910868542",
      "name": "Combine schema data and chat input",
      "type": "n8n-nodes-base.set",
      "position": [
        -3296,
        -80
      ],
      "executeOnce": true,
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "agent": "conversationalAgent",
        "promptType": "define",
        "text": "=Here is the database schema: {{ $json.schema }}\nHere is the user request: {{ $json.chatinput }}",
        "options": {
          "humanMessage": "TOOLS\n------\nAssistant can ask the user to use tools to look up information that may be helpful in answering the users original question. The tools the human can use are:\n\n{tools}\n\n{format_instructions}\n\nUSER'S INPUT\n--------------------\nHere is the user's input (remember to respond with a markdown code snippet of a json blob with a single action, and NOTHING else):\n\n{{input}}",
          "systemMessage": "=Você é um GERADOR DE SQL para **PostgreSQL** guiado por um JSON de esquema chamado **SCHEMA**. \nSeu objetivo é produzir consultas 100% válidas, seguras e fiéis ao SCHEMA — sem inventar nada.\n\n====================================================================\nENTRADAS\n- SCHEMA: objeto JSON com:\n  • tabelas[*].nome\n  • tabelas[*].colunas[*].nome, .tipo, .pk?, .fk? (tabela_referenciada, coluna_referenciada)\n  • relacionamentos[] (from=\"A.x\", to=\"B.y\")  // opcional, complementar às FKs\n- PEDIDO: descrição do que o usuário quer consultar.\n\n====================================================================\nFONTES DE VERDADE (use AMBAS)\n1) Definição de tabelas e colunas em SCHEMA.tabelas.\n2) Relacionamentos explícitos em:\n   a) SCHEMA.tabelas[*].colunas[*].fk\n   b) SCHEMA.relacionamentos (from=\"A.x\", to=\"B.y\")\n\nSe algo não existir nessas fontes, **não existe**.\n\n====================================================================\nREGRAS ABSOLUTAS\n- Gere apenas SELECT (inclui WITH … SELECT). Se o usuário pedir DDL/DML, responda exatamente: ‘Somente SELECT é permitido…’ e não gere SQL.\n- Use **apenas** tabelas que existirem em SCHEMA.tabelas[*].nome e colunas que existirem em SCHEMA.tabelas[*].colunas[*].nome.\n- **JOINS só são permitidos** se houver relacionamento em AO MENOS UMA fonte (FK na coluna OU SCHEMA.relacionamentos). \n  • Aceite A→B ou B→A. \n  • Se não houver caminho direto, tente uma **tabela ponte** existente no SCHEMA.\n  • Se não houver caminho algum, **explique e NÃO gere SQL**.\n- **NÃO invente** tabelas, colunas, joins, funções, enums ou filtros. Se algo não existir, **explique e PARE**.\n- Dialeto: **PostgreSQL**. \n  • Identificadores SEMPRE entre aspas duplas: \"tabela\".\"coluna\". \n  • Strings entre aspas simples. \n  • Evite `SELECT *`; projete apenas as colunas necessárias. \n  • Para contagens, use `COUNT(*)`.\n- **Enums via VIEW** (padrão: \"vAlgo\" com colunas \"Codigo\"/\"Descricao\"):\n  • Para filtrar/join: **use \"Codigo\"** (não compare por \"Descricao\"). \n  • Para exibir texto: selecione **\"Descricao\"** após o JOIN.\n- **Filtros em CTE/subselects**: quando usar CTEs/subconsultas, aplique **filtros na consulta EXTERNA** (para não alterar cardinalidade por engano).\n- **Funções de janela**: se precisar, calcule em CTE; **NUNCA** use janela em WHERE, HAVING, JOIN ON ou GROUP BY.\n- **Segurança e tipos**:\n  • Nunca assuma tipos; se preciso, use casts explícitos `::tipo`. \n  • Nunca insira/interpole valores do usuário diretamente; use **placeholders** `$1, $2, ...`. \n  • Nunca gere múltiplos statements; produza **uma** consulta final.\n\nObservação: use **nomes canônicos do SCHEMA** (ex.: \"UC_Ligacao\", sem acento). Variações não existem.\n\n====================================================================\nCHECKLIST OBRIGATÓRIO (FAÇA ANTES DE GERAR SQL)\n1) **Tabelas** pedidas existem em SCHEMA.tabelas?\n2) **Colunas** pedidas existem nas tabelas correspondentes?\n3) **Joins**:\n   • Há caminho válido entre as tabelas (via FKs ou SCHEMA.relacionamentos)?  \n   • Se houver mais de um caminho, é inequívoco? Se **ambíguo**, **explique e NÃO gere SQL**.\n4) **Enums**:\n   • Alguma coluna tem semântica de enum (ex.: *_Status, *_Situacao, *_Tipo, *_Categoria)?  \n   • Para exibir texto: JOIN na view \"v...\" e selecione \"Descricao\".  \n   • Para filtrar: use \"Codigo\" (nunca \"Descricao\").\n5) **Tipos**:\n   • Comparações e datas exigem cast? Use `::tipo` (ex.: `to_date($1,'MM/YYYY')`, `date_trunc('month',col)`), sem suposições implícitas.\n6) **CTE/Subselect**:\n   • Se existirem, mantenha filtros na consulta EXTERNA.\n7) **Parâmetros**:\n   • Todos os valores do usuário estão parametrizados como `$1, $2, ...`?\n\nSe alguma verificação falhar, **explique o motivo e NÃO gere SQL**.\n\n====================================================================\nPOLÍTICAS DE QUALIDADE\n- **Agrupamento/Ordenação**: agrupe apenas pelo necessário; use aliases no ORDER BY.\n- **Performance**: prefira JOINs a subconsultas correlatas; use `EXISTS` vs `IN` quando adequado; evite CROSS JOIN acidental; use CTEs para clareza quando ajudarem.\n- **Leitura**: use aliases claros para tabelas (ex.: l, uc, vc) e comente linhas sensíveis com `--`.\n- **Saída única**: uma única consulta; se múltiplas etapas, use CTEs.\n\n====================================================================\nFORMATO DE RESPOSTA (OBRIGATÓRIO)\nSaída:\n-- Apenas a query gerada\n"
        }
      },
      "id": "9b1b18ff-3f74-4667-bd37-fee101077967",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        -3088,
        64
      ],
      "typeVersion": 1.6
    },
    {
      "parameters": {
        "operation": "fromJson",
        "binaryPropertyName": "json",
        "destinationKey": "json",
        "options": {
          "encoding": "utf8"
        }
      },
      "id": "b8d8705e-d069-47ff-a7db-0d869edd4f07",
      "name": "Extract data from file",
      "type": "n8n-nodes-base.extractFromFile",
      "position": [
        -3488,
        -80
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "model": "gpt-4.1-mini",
        "options": {
          "maxTokens": 1024,
          "temperature": 0.2
        }
      },
      "id": "24940701-69c4-4809-a92d-853a1b8fe88e",
      "name": "OpenAI Chat Model1",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        -3088,
        272
      ],
      "typeVersion": 1,
      "credentials": {
        "openAiApi": {
          "id": "LNm0mA6pNKzVyNdi",
          "name": "OpenAi datamobil_VX"
        }
      }
    },
    {
      "parameters": {
        "contextWindowLength": 10
      },
      "id": "44e982b1-c94f-47cc-894b-f3f6ae97345b",
      "name": "Window Buffer Memory1",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "position": [
        -2960,
        320
      ],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ $('Extract SQL query').item.json.query }}",
        "options": {
          "connectionTimeout": 180
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1920,
        -288
      ],
      "id": "3f6d92b1-fb8d-4f6c-b748-a3131124e003",
      "name": "Execute a SQL query",
      "alwaysOutputData": true,
      "executeOnce": false,
      "credentials": {
        "postgres": {
          "id": "6iqsLXZTqf2rK4YA",
          "name": "Postgres account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b86f4807-aff3-42fb-a110-f43653368396",
              "name": "Solicitacao",
              "value": "={{ $json.query.Solicitacao }}",
              "type": "string"
            },
            {
              "id": "66447438-499c-4ab3-88ee-e20835aa7618",
              "name": "CodigoIManager",
              "value": "={{ $json.query.CodigoIManager }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4176,
        -80
      ],
      "id": "f7fb7dde-9165-4dea-ad12-ee039de1804a",
      "name": "Setar informações de Parâmetros"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        -1504,
        80
      ],
      "id": "53f4f6c1-fcdc-45be-81d1-3a2e151e667d",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "path": "datamobilIA",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "data",
          "responseHeaders": {
            "entries": [
              {
                "name": "Solicitacao"
              },
              {
                "name": "CNPJ"
              },
              {
                "name": "CodigoManager"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -4432,
        -80
      ],
      "id": "bb9bef77-e7b6-40de-927b-b84adcea4a0f",
      "name": "Entrada",
      "webhookId": "4d110ba1-2fc6-4d65-810a-362b2d518210"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f8f105fa-8e7c-4309-9cd9-9a5c987ed77f",
              "leftValue": "={{ $json.allowed }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2224,
        -192
      ],
      "id": "0a5bb9ce-87d6-4a0c-94c8-916e659acae9",
      "name": "If1"
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items\n\nconst items = $input.all();\n\n// --- Utils ------------------------------------------------------------------\n\nfunction hasMeaningfulContent(o, depth = 0) {\n  if (o == null) return false;\n  if (typeof o !== 'object') return String(o).trim() !== '';\n  if (depth > 6) return true;\n  if (Array.isArray(o)) return o.some(v => hasMeaningfulContent(v, depth + 1));\n  const keys = Object.keys(o);\n  if (keys.length === 0) return false;\n  return keys.some(k => hasMeaningfulContent(o[k], depth + 1));\n}\n\nfunction collectErrorsDeep(obj, found = []) {\n  if (obj == null) return found;\n\n  const pushErr = (val) => {\n    if (val == null) return;\n    const msg = typeof val === 'object' ? JSON.stringify(val) : String(val);\n    if (msg.trim()) found.push(msg.trim());\n  };\n\n  if (Array.isArray(obj)) {\n    for (const v of obj) collectErrorsDeep(v, found);\n    return found;\n  }\n\n  if (typeof obj === 'object') {\n    for (const [k, v] of Object.entries(obj)) {\n      const lower = k.toLowerCase();\n      if (lower === 'erro' || lower === 'error') pushErr(v);\n      else if (lower === 'message' && typeof v === 'string') pushErr(v);\n      collectErrorsDeep(v, found);\n    }\n    return found;\n  }\n\n  return found;\n}\n\nfunction dedupStrings(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const s of arr) if (!seen.has(s)) { seen.add(s); out.push(s); }\n  return out;\n}\n\n// Preferência do Luis: $json.message.content.data\nfunction extractUsefulPayload(j) {\n  if (Array.isArray(j?.message?.content?.data)) return j.message.content.data.slice();\n  if (Array.isArray(j?.data)) return j.data.slice();\n  if (hasMeaningfulContent(j)) return [j];\n  return [];\n}\n\nfunction normalizeList(list) {\n  return list\n    .map(x => (x?.json ?? x))\n    .filter(o => hasMeaningfulContent(o))\n    .map(o => (typeof o === 'object' ? o : { value: o }));\n}\n\n// Captura a query de forma resiliente (suporta Set, Function e mesmo payload)\nfunction safeGetQuery() {\n  // 1) Se a query veio nos itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const q = j.query ?? j.sql ?? j.consulta;\n    if (typeof q === 'string' && q.trim()) return q.trim();\n  }\n\n  // 2) Caso a query esteja em outro nó do fluxo\n  try {\n    // Altere o nome abaixo para o nó onde a SQL é montada (ex: \"Extract SQL query\" ou \"Montar Query\")\n    const fromNode = $items('Extract SQL query', 0, 0);\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const q = j.query ?? j.sql ?? j.consulta;\n      if (typeof q === 'string' && q.trim()) return q.trim();\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null; // não encontrada\n}\n\n// --- Fluxo ------------------------------------------------------------------\n\n// 1) Sem entradas\nif (!items || items.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação' } }];\n}\n\n// 2) Procure erros em todo o payload bruto\nlet erros = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  collectErrorsDeep(j, erros);\n}\nerros = dedupStrings(erros);\n\n// 3) Se achou erro, retorna somente { Erro }\nif (erros.length > 0) {\n  return [{ json: { Erro: erros[0] } }];\n}\n\n// 4) Extrair dados dos formatos suportados\nlet all = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  all.push(...extractUsefulPayload(j));\n}\n\n// 5) Fallback: cada item.json\nif (all.length === 0) {\n  all = items.map(i => i?.json ?? {});\n}\n\n// 6) Checar erros dentro da lista\nlet innerErrors = [];\ncollectErrorsDeep(all, innerErrors);\ninnerErrors = dedupStrings(innerErrors);\nif (innerErrors.length > 0) {\n  return [{ json: { Erro: innerErrors[0] } }];\n}\n\n// 7) Limpeza de dados\nconst rows = normalizeList(all);\n\n// 8) Captura a query (sem quebrar se não existir)\nconst query = safeGetQuery();\n\n// 9) Sem dados → erro padrão\nif (rows.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação' } }];\n}\n\n// 10) OK: retorna SEMPRE { data, query }\nreturn [{ json: { data: rows, query } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1696,
        80
      ],
      "id": "dad0a3d3-f4c8-467c-9203-1cf0fe71a940",
      "name": "Repassar dados"
    },
    {
      "parameters": {
        "jsCode": "// Entrada: { sql: \"SELECT ...\", userPrompt: \"...\" }  (ajuste nomes se preciso)\nlet sql = ($('Extract SQL query').first().json.query || \"\").trim();\n\n// 1) Remove comentários (-- e /* */) e normaliza espaços\nconst stripComments = s => {\n  // remove /* ... */ (multilinha)\n  s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, ' ');\n  // remove -- até o fim da linha\n  s = s.replace(/--.*$/gm, ' ');\n  return s;\n};\nconst cleaned = stripComments(sql).replace(/\\s+/g, ' ').trim();\n\nconst forbidden = /\\b(SOMENTE|INSERT|UPDATE|DELETE|MERGE|CREATE|ALTER|DROP|TRUNCATE|GRANT|REVOKE|COMMENT|VACUUM|COPY|REFRESH|CALL|DO|BEGIN|COMMIT|ROLLBACK|SET|LOCK|CLUSTER|REINDEX|DISCARD)\\b/i;\nif (forbidden.test(cleaned)) {\n  return [{ \n    allowed: false, \n    reason: \"Contém comando proibido.\", \n    erro: `Somente SELECT é permitido. Não posso executar DDL/DML.\n    Detalhes: ` + $input.first().json.output\n  }];\n}\n\nreturn [{ allowed: true, sql }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2416,
        -192
      ],
      "id": "1dd167c3-a446-4114-a42c-aeac08795d80",
      "name": "Extrair query"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Run Once for Each Item\n// devolve UM item por entrada (sem colchetes)\nconst msg = $json.output; \nreturn {\n  json: {\n      erro:msg ?? \"Por favor, forneça a consulta ou pergunta específica que deseja realizar com base no esquema fornecido.\"\n  }\n};\n\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2368,
        -48
      ],
      "id": "5de34ea2-6a30-455b-96c4-143adefcc854",
      "name": "Mensagem de query inválida"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Run Once for Each Item\n/**\n const msg = \"Solicitação contém comando proibido, somente SELECT é permitido. Não posso executar DDL/DML.\";\n */\nconst msg = $json.erro;\nreturn {\n  json: { erro: msg }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1952,
        -128
      ],
      "id": "22fc2459-0b02-4f59-89f4-73e0fdaa7a50",
      "name": "Mensagem de query Proibida"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item;\nconst j = item.json;\n\nconst configuracaoPorCliente = {\n  \"0001\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"52.45.149.188\",\n    bancodedados: \"icommercial_faturamento_teste_luis\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"3738\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"52.45.149.188\",\n    bancodedados: \"icommercial_faturamento_teste_luis\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"testedev2\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"rabbitmq.icommercial002.inovamobil.com.br\",\n    bancodedados: \"icommercial_faturamento_testedev2\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n};\n\n// ==== OBRIGATÓRIO TER código do IManager ====\nconst codigoIManager = (j.CodigoIManager ?? \"\");\nconst selected = configuracaoPorCliente[codigoIManager];\nif (!selected) {\n  throw new Error(\n    `Cliente ` + codigoIManager + ` não informado, favor validar para utilização do módulo.`\n  );\n}\n\nj.configuracao = {\n    host: selected.servidor,\n    database: selected.bancodedados,\n    user: selected.usuario,\n    password: selected.senha,\n    port: selected.porta,\n  };\n\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3936,
        -80
      ],
      "id": "9a5a9f68-1e82-493e-8c31-7b2fdc044103",
      "name": "Constantes"
    }
  ],
  "connections": {
    "Download file": {
      "main": [
        [
          {
            "node": "Extract data from file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if query exists": {
      "main": [
        [
          {
            "node": "Extrair query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mensagem de query inválida",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract SQL query": {
      "main": [
        [
          {
            "node": "Check if query exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine schema data and chat input": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Extract SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract data from file": {
      "main": [
        [
          {
            "node": "Combine schema data and chat input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Window Buffer Memory1": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setar informações de Parâmetros": {
      "main": [
        [
          {
            "node": "Constantes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entrada": {
      "main": [
        [
          {
            "node": "Setar informações de Parâmetros",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mensagem de query Proibida",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repassar dados": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extrair query": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mensagem de query inválida": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mensagem de query Proibida": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Constantes": {
      "main": [
        [
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "9e37b43d-f7c7-481e-8762-255cedef2bc7",
  "triggerCount": 1,
  "shared": [
    {
      "createdAt": "2025-09-19T11:54:07.415Z",
      "updatedAt": "2025-09-19T11:54:07.415Z",
      "role": "workflow:owner",
      "workflowId": "WGrMI37RtIUZmJkQ",
      "projectId": "bDUBly1zU3yziLIn"
    }
  ],
  "tags": [],
  "hasBackup": false,
  "backupData": null,
  "backupUpdatedAt": null,
  "parseError": "The first argument must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object. Received undefined",
  "workflowId": "WGrMI37RtIUZmJkQ",
  "workflowName": "Datamobil - VX Embedded - Homologação",
  "filePath": "backups/workflows/WGrMI37RtIUZmJkQ.json",
  "workflowUpdatedAt": "2025-11-12T19:13:21.000Z",
  "status": "CRIAR"
}