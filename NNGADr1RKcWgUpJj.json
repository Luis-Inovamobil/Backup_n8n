{
  "id": "NNGADr1RKcWgUpJj",
  "name": "Datamobil - VX Embedded - Produção",
  "createdAt": "2025-09-08T19:14:20.112Z",
  "updatedAt": "2025-12-24T14:56:51.000Z",
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "https://drive.google.com/file/d/1FRiLlc_JW6m_25AcDmtr2l8qj4qsjwFR/view?usp=drive_link",
          "mode": "url"
        },
        "options": {
          "binaryPropertyName": "json"
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        48,
        432
      ],
      "id": "eceb052d-2c16-4cba-b74a-e4e2068d9b39",
      "name": "Download file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "A7dItjE7OWcTVPSQ",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "5f3b3c30-78e9-4ed0-b520-9153664540ec",
              "leftValue": "={{ $json.query }}",
              "rightValue": "SELECT",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "fbb4885e-831f-4523-8d31-ce394fb5a1b0",
      "name": "Check if query exists",
      "type": "n8n-nodes-base.if",
      "position": [
        1136,
        448
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "42abd24e-419a-47d6-bc8b-7146dd0b8314",
              "name": "sessionId",
              "type": "string",
              "value": "={{ $('Entrada').item.json.query.CNPJ }}"
            },
            {
              "id": "f78c57d9-df13-43c7-89a7-5387e528107e",
              "name": "chatinput",
              "type": "string",
              "value": "={{ $('Entrada').item.json.query.Solicitacao }}"
            },
            {
              "id": "e42b39eb-dfbd-48d9-94ed-d658bdd41454",
              "name": "schema",
              "type": "string",
              "value": "={{ $json.json }}"
            }
          ]
        },
        "options": {}
      },
      "id": "45b8dafb-379d-4180-a923-7a8b9b5b9e85",
      "name": "Combine schema data and chat input",
      "type": "n8n-nodes-base.set",
      "position": [
        448,
        432
      ],
      "executeOnce": true,
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Here is the database schema: {{ $json.schema }}\nHere is the user request: {{ $json.chatinput }}",
        "options": {
          "systemMessage": "=Você é um GERADOR DE SQL para PostgreSQL guiado por um JSON de esquema chamado SCHEMA. Seu objetivo é produzir UMA ÚNICA consulta SELECT 100% válida, segura e fiel ao SCHEMA — sem inventar nada.\n\n====================================================================\nEXEMPLO GUIADO (NÃO REPITA NA RESPOSTA FINAL)\nExemplo de uso correto para pedidos de 3 meses consecutivos:\nPEDIDO_EXEMPLO:\n\"Liste todas as ligações que tiveram por 3 meses consecutivos no ano de 2025 a ocorrência LEITURA FORA DE FAIXA. Preciso que exiba o código da ligação, as referências e o código da ocorrência.\"\n\nRESPOSTA_EXEMPLO (SQL CORRETA):\nWITH base AS (\n  SELECT DISTINCT\n    ul.\"UC_Lig_Id\",\n    ul.\"UC_Leit_Ocorrencia_1\" AS ocorrencia_codigo,\n    to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') AS ref_date\n  FROM \"UC_Leitura\" ul\n  JOIN \"Ocorrencias\" o\n    ON o.\"Oco_Codigo\" = ul.\"UC_Leit_Ocorrencia_1\"\n  WHERE\n    o.\"Oco_Descricao\" ILIKE 'LEITURA FORA DE FAIXA'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') >= DATE '2025-01-01'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') < DATE '2026-01-01'\n),\nseq AS (\n  SELECT\n    b.\"UC_Lig_Id\",\n    b.ocorrencia_codigo,\n    b.ref_date,\n    row_number() OVER (PARTITION BY b.\"UC_Lig_Id\" ORDER BY b.ref_date) AS rn,\n    (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n      - row_number() OVER (PARTITION BY b.\"UC_Lig_Id\" ORDER BY b.ref_date) AS grp\n  FROM base b\n),\nruns AS (\n  SELECT\n    \"UC_Lig_Id\",\n    ocorrencia_codigo,\n    grp,\n    MIN(ref_date) AS ref1,\n    COUNT(*) AS len\n  FROM seq\n  GROUP BY\n    \"UC_Lig_Id\", ocorrencia_codigo, grp\n  HAVING COUNT(*) >= 3\n)\nSELECT\n  \"UC_Lig_Id\" AS \"Codigo_Ligacao\",\n  to_char(ref1, 'MM/YYYY') AS \"Referencia_1\",\n  to_char(ref1 + INTERVAL '1 month', 'MM/YYYY') AS \"Referencia_2\",\n  to_char(ref1 + INTERVAL '2 month', 'MM/YYYY') AS \"Referencia_3\",\n  ocorrencia_codigo AS \"Codigo_Ocorrencia\"\nFROM runs\nORDER BY \"Codigo_Ligacao\", \"Referencia_1\";\n\nFIM DO EXEMPLO.\nUSE ESTE ESTILO COMO REFERÊNCIA.\n====================================================================\n\nREGRAS PRIORITÁRIAS (NÃO PODE DESCUMPRIR)\n1) É PROIBIDO usar COUNT(). SEMPRE use COUNT(*).\n2) É PROIBIDO escrever extract(year FROM algo)12. SEMPRE escreva extract(year FROM algo)*12.\n3) Se o PEDIDO falar de “3 meses consecutivos”, “3 leituras seguidas”, “3 faturas consecutivas” ou equivalente, você DEVE usar a fórmula:\n   (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n   - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n\nSe qualquer uma dessas regras for violada na sua consulta, você NÃO pode retorná-la.\nEm vez disso, responda apenas:\n\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n====================================================================\n\nENTRADAS\n- SCHEMA: objeto JSON (⦃schema⦄) com:\n  • tabelas[*].nome\n  • tabelas[*].colunas[*].nome, tipo, pk?, fk?\n  • relacionamentos[] (from=\"A.x\", to=\"B.y\")\n  • regras.periodo_MMYYYY, regras.streak_MMYYYY, regras.sql_lints,\n    regras.required_patterns, regras.templates, regras.sql_rewrites (se existirem)\n- PEDIDO: descrição do que o usuário quer consultar (⦃pedido⦄).\n\n====================================================================\nFONTES DE VERDADE\n1) SCHEMA.tabelas/colunas\n2) Relacionamentos explícitos (FKs ou SCHEMA.relacionamentos)\n3) “regras.*” do SCHEMA (SE EXISTIREM) são obrigatórias.\n\nSe algo não existir no SCHEMA, considere que NÃO existe: explique e NÃO gere SQL.\n\n====================================================================\nREGRAS GERAIS\n- Gere apenas SELECT (pode conter WITH). Nunca gere UPDATE, DELETE, INSERT, CREATE, DROP, etc.\n- Use somente tabelas/colunas existentes no SCHEMA.\n- JOINS só podem ser feitos quando existe um relacionamento válido.\n- Identificadores SEMPRE entre aspas duplas \"…\".\n- Strings SEMPRE com aspas simples '…'.\n- Nunca use SELECT *.\n- COUNT(*) sempre que precisar contar.\n- Nunca invente colunas ou tabelas.\n\n====================================================================\nPERÍODO MM/YYYY (OBRIGATÓRIO se aplicável)\nSe existir SCHEMA.regras.periodo_MMYYYY para a coluna usada:\n- Para filtrar por ano (ex.: 2025), use:\n  to_date(coluna, 'MM/YYYY') >= DATE '{{ano}}-01-01'\n  AND to_date(coluna, 'MM/YYYY') < DATE '{{ano_next}}-01-01'\n\n- É PROIBIDO usar LIKE ou ILIKE em coluna MM/YYYY.\n\n====================================================================\n3 MESES CONSECUTIVOS (streak_MMYYYY)\nSempre que o PEDIDO mencionar:\n- \"3 meses consecutivos\", \"3 leituras seguidas\",\n- \"3 leituras consecutivas\", \"3 faturas seguidas\", etc.\n\nVocê DEVE aplicar o método padrão baseado em row_number():\nWITH base (...)\nWITH seq (...)\nWITH runs (...)\nRespeitando:\n- row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n- Fórmula obrigatória:\n  (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n  - row_number() OVER (...)\n\n- HAVING COUNT(*) >= 3 (ou min_streak_default)\n\n====================================================================\nUSO DE TEMPLATES DO SCHEMA\nSe SCHEMA.regras.templates.tres_meses_consecutivos_generico existir:\n- Você DEVE usar o template como base\n- Só pode alterar placeholders:\n  {{padrao}}, {{ano}}, {{ano_next}}\n\n====================================================================\nREGRAS DE REWRITES E REQUIRED PATTERNS\nSe SCHEMA.regras.sql_rewrites existir:\n- Aplique as substituições obrigatórias\nDepois valide required_patterns.\n\n====================================================================\nCHECKLIST FINAL (AUTO-CHECAGEM)\nAntes de retornar a query, confirme:\n1) NÃO contém COUNT()\n2) NÃO contém extract(year FROM …)12\n3) NÃO usa LIKE/ILIKE em colunas MM/YYYY\n4) Se for streak:\n   - row_number() obrigatório\n   - fórmula obrigatória\n   - HAVING COUNT(*)\n\nSe falhar:  \n\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n====================================================================\nREGRA ADICIONAL 1 (CLIENTE = LIGAÇÃO)\nQuando o PEDIDO mencionar “clientes” mas o SCHEMA não tiver relação 1:1 entre cliente e ligação:\n- Considere UC_Lig_Id como identificador do “cliente”.\n- NÃO use Pes_Codigo, a menos que o pedido explicitamente peça dados da pessoa.\n- Streaks, agrupamentos, contagens percentuais e indicadores devem ser feitos por ligação.\n\n====================================================================\nREGRA ADICIONAL 2 (CATEGORIA DA LIGAÇÃO)\nQuando o PEDIDO envolver categoria da ligação (Residencial, Comercial, Industrial, etc.):\n- A categoria “normal” da ligação usa SEMPRE o catálogo vCategoria (1=Residencial, 2=Comercial, 3=Industrial, 4=Publica, 5=Outros).\n- Você pode obter essa categoria a partir de:\n  • UC_Categoria.UC_Cat_Categoria → vCategoria\n  • UC_Leitura_Categoria.UC_LeitCat_Categoria → vCategoria\n- Use UC_Categoria quando a pergunta for sobre a categoria ATUAL da ligação.\n- Use UC_Leitura_Categoria quando a pergunta estiver ligada a leituras/faturas em um período (ex.: “em 2025”).\n- Nunca use campos ligados a vTipoCategoriaRecalculo para responder perguntas sobre a categoria “normal” da ligação.\n\n====================================================================\nREGRA ADICIONAL 3 (LEITURAS ESTIMADAS)\nQuando o PEDIDO falar de “leituras estimadas” ou “consumo estimado”:\n\n- Uma leitura é considerada ESTIMADA quando, para a ligação (UC_Lig_Id) associada:\n\n  1) A ligação NÃO possui hidrômetro ativo:\n     NÃO deve existir registro em \"UC_Hidrometro\" com:\n        • \"UC_Hidrometro\".\"UC_Lig_Id\" = \"UC_Leitura\".\"UC_Lig_Id\"\n        • \"UC_Hidrometro\".\"UC_Hid_Ativo\" = TRUE\n\n  2) E existir registro em \"UC_Parametros\" com:\n        • \"UC_Parametros\".\"UC_Lig_Id\" = \"UC_Leitura\".\"UC_Lig_Id\"\n        • \"UC_Parametros\".\"UC_Par_Consumo_Estimado\" > 0\n\n- Para calcular quantidade ou taxa de leituras estimadas:\n  • Trate TODAS as leituras da ligação que satisfazem essas duas condições como “estimadas”.\n  • NÃO use apenas campos como \"UC_Leit_Leitura_Calculada\" para identificar estimadas.\n\n====================================================================\nREGRA ADICIONAL 4 (CÁLCULO DE TAXA PERCENTUAL)\nQuando precisar calcular uma taxa percentual (por exemplo, taxa de leituras estimadas por rota):\n\n- PRIMEIRO faça uma agregação em um nível (por exemplo, por rota), calculando:\n  • COUNT(*)            AS total_registros\n  • COUNT(*) FILTER (WHERE <condicao>) AS quantidade_com_condicao\n\n- SÓ DEPOIS, em um SELECT externo (ou CTE), calcule o percentual usando EXATAMENTE o padrão:\n\n  ROUND(\n    CASE\n      WHEN total_registros = 0 THEN 0\n      ELSE quantidade_com_condicao::numeric / total_registros::numeric * 100\n    END\n  , 2) AS nome_da_taxa\n\n- Evite montar expressões muito longas com CASE + COUNT(*) FILTER aninhados diretamente na mesma camada do GROUP BY, para reduzir erros de parênteses.\n- Sempre que possível, use:\n  • um CTE de agregação (ex.: agg_por_rota)\n  • e um SELECT final apenas para calcular a taxa a partir de total_registros e quantidade_com_condicao.\n\n====================================================================\nFORMATO DE RESPOSTA\n- Se tudo estiver correto → retorne somente a SQL final.\n- Se violar qualquer regra → retorne:\n  \"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n",
          "maxIterations": 1
        }
      },
      "id": "a39a4d0e-d6d2-4898-a9fa-359d3994ac63",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        -272,
        784
      ],
      "typeVersion": 1.6,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "fromJson",
        "binaryPropertyName": "json",
        "destinationKey": "***MASKED_SECRET***",
        "options": {
          "encoding": "utf8"
        }
      },
      "id": "aa7febb9-ec73-446e-84af-c335abb20cc4",
      "name": "Extract data from file",
      "type": "n8n-nodes-base.extractFromFile",
      "position": [
        256,
        432
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "model": "gpt-5-mini",
        "options": {
          "maxTokens": "***MASKED_SECRET***",
          "maxRetries": 2
        }
      },
      "id": "8c6694ff-96f4-4798-a934-c26761d998b4",
      "name": "OpenAI Chat Model1",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        -272,
        992
      ],
      "typeVersion": 1,
      "credentials": {
        "openAiApi": {
          "id": "LNm0mA6pNKzVyNdi",
          "name": "OpenAi datamobil_VX"
        }
      }
    },
    {
      "parameters": {
        "contextWindowLength": 3
      },
      "id": "f658bf79-835e-486d-bf79-bac4c0b75eb4",
      "name": "Window Buffer Memory1",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "position": [
        -144,
        1040
      ],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ $('Extract SQL query').item.json.query }}",
        "options": {
          "connectionTimeout": 180
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1824,
        224
      ],
      "id": "082311bb-be8a-4165-ae0b-519b80286d5e",
      "name": "Execute a SQL query",
      "alwaysOutputData": true,
      "executeOnce": false,
      "credentials": {
        "postgres": {
          "id": "6iqsLXZTqf2rK4YA",
          "name": "Postgres account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b86f4807-aff3-42fb-a110-f43653368396",
              "name": "Solicitacao",
              "value": "={{ $json.query.Solicitacao }}",
              "type": "string"
            },
            {
              "id": "66447438-499c-4ab3-88ee-e20835aa7618",
              "name": "CodigoIManager",
              "value": "={{ $json.query.CodigoIManager }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -432,
        432
      ],
      "id": "405d26ac-9b05-4f31-9d58-ea05b09d36ec",
      "name": "Setar informações de Parâmetros"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        2240,
        576
      ],
      "id": "653cc375-23ca-4179-8959-14759f57acf2",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "path": "analyticsIA",
        "responseMode": "responseNode",
        "options": {
          "binaryPropertyName": "data",
          "responseHeaders": {
            "entries": [
              {
                "name": "Solicitacao"
              },
              {
                "name": "CNPJ"
              },
              {
                "name": "CodigoManager"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -688,
        432
      ],
      "id": "8d7f940f-6005-4df8-bd10-02dc8933b7c5",
      "name": "Entrada",
      "webhookId": "4d110ba1-2fc6-4d65-810a-362b2d518210"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "f8f105fa-8e7c-4309-9cd9-9a5c987ed77f",
              "leftValue": "={{ $json.allowed }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1520,
        320
      ],
      "id": "faa155f3-664d-4905-b84a-4c4020bd17b9",
      "name": "If1"
    },
    {
      "parameters": {
        "jsCode": "// Run Once for All Items\n\nconst items = $input.all();\n\n// --- Utils ------------------------------------------------------------------\n\nfunction hasMeaningfulContent(o, depth = 0) {\n  if (o == null) return false;\n  if (typeof o !== 'object') return String(o).trim() !== '';\n  if (depth > 6) return true;\n  if (Array.isArray(o)) return o.some(v => hasMeaningfulContent(v, depth + 1));\n  const keys = Object.keys(o);\n  if (keys.length === 0) return false;\n  return keys.some(k => hasMeaningfulContent(o[k], depth + 1));\n}\n\nfunction collectErrorsDeep(obj, found = []) {\n  if (obj == null) return found;\n\n  const pushErr = (val) => {\n    if (val == null) return;\n    const msg = typeof val === 'object' ? JSON.stringify(val) : String(val);\n    if (msg.trim()) found.push(msg.trim());\n  };\n\n  if (Array.isArray(obj)) {\n    for (const v of obj) collectErrorsDeep(v, found);\n    return found;\n  }\n\n  if (typeof obj === 'object') {\n    for (const [k, v] of Object.entries(obj)) {\n      const lower = k.toLowerCase();\n      if (lower === 'erro' || lower === 'error') pushErr(v);\n      else if (lower === 'message' && typeof v === 'string') pushErr(v);\n      collectErrorsDeep(v, found);\n    }\n    return found;\n  }\n\n  return found;\n}\n\nfunction dedupStrings(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const s of arr) if (!seen.has(s)) { seen.add(s); out.push(s); }\n  return out;\n}\n\n// Preferência do Luis: $json.message.content.data\nfunction extractUsefulPayload(j) {\n  if (Array.isArray(j?.message?.content?.data)) return j.message.content.data.slice();\n  if (Array.isArray(j?.data)) return j.data.slice();\n  if (hasMeaningfulContent(j)) return [j];\n  return [];\n}\n\nfunction normalizeList(list) {\n  return list\n    .map(x => (x?.json ?? x))\n    .filter(o => hasMeaningfulContent(o))\n    .map(o => (typeof o === 'object' ? o : { value: o }));\n}\n\n// Captura a query de forma resiliente (suporta Set, Function e mesmo payload)\nfunction safeGetQuery() {\n  // 1) Se a query veio nos itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const q = j.query ?? j.sql ?? j.consulta;\n    if (typeof q === 'string' && q.trim()) return q.trim();\n  }\n\n  // 2) Caso a query esteja em outro nó do fluxo\n  try {\n    // Ajuste para o nome do nó onde a SQL é montada\n    const fromNode = $items('Extrair query', 0, 0);\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const q = j.query ?? j.sql ?? j.consulta;\n      if (typeof q === 'string' && q.trim()) return q.trim();\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null; // não encontrada\n}\n\nfunction findUsageIn(obj) {\n  if (obj == null) return null;\n\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      const found = findUsageIn(el);\n      if (found) return found;\n    }\n    return null;\n  }\n\n  if (typeof obj === 'object') {\n    if (obj.usage && typeof obj.usage === 'object') {\n      const u = obj.usage;\n      const total =\n        typeof u.total_tokens === 'number'\n          ? u.total_tokens\n          : (typeof u.input_tokens === 'number' && typeof u.output_tokens === 'number'\n              ? u.input_tokens + u.output_tokens\n              : undefined);\n\n      return {\n        input_tokens: typeof u.input_tokens === 'number' ? u.input_tokens : undefined,\n        output_tokens: typeof u.output_tokens === 'number' ? u.output_tokens : undefined,\n        total_tokens: typeof total === 'number' ? total : undefined,\n      };\n    }\n\n    for (const v of Object.values(obj)) {\n      const found = findUsageIn(v);\n      if (found) return found;\n    }\n  }\n\n  return null;\n}\n\nfunction safeGetUsage() {\n  // 1) Tenta achar usage nos próprios itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const usage = findUsageIn(j);\n    if (usage) return usage;\n  }\n\n  // 2) Tenta achar usage no nó \"GPT gerar query\"\n  try {\n    const fromNode = $items('GPT gerar query'); // <<--- AQUI entra o seu nó\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const usage = findUsageIn(j);\n      if (usage) return usage;\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null;\n}\n\n// --- Fluxo ------------------------------------------------------------------\n\n// Captura a query logo no início, para usá-la em QUALQUER retorno\nconst query = safeGetQuery();\n\nconsole.log(query)\n\n// 1) Sem entradas\nif (!items || items.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação', query, errors: ['Input vazio'] } }];\n}\n\n// 2) Procure erros em todo o payload bruto\nlet outerErrors = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  collectErrorsDeep(j, outerErrors);\n}\nouterErrors = dedupStrings(outerErrors);\n\n// 3) Se achou erro, retorna { Erro, query, errors }\nif (outerErrors.length > 0) {\n  return [{ json: { Erro: outerErrors[0], query, errors: outerErrors } }];\n}\n\n// 4) Extrair dados dos formatos suportados\nlet all = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  all.push(...extractUsefulPayload(j));\n}\n\n// 5) Fallback: cada item.json\nif (all.length === 0) {\n  all = items.map(i => i?.json ?? {});\n}\n\n// 6) Checar erros dentro da lista\nlet innerErrors = [];\ncollectErrorsDeep(all, innerErrors);\ninnerErrors = dedupStrings(innerErrors);\nif (innerErrors.length > 0) {\n  const errors = dedupStrings([...outerErrors, ...innerErrors]);\n  return [{ json: { Erro: innerErrors[0], query, errors } }];\n}\n\n// 7) Limpeza de dados\nconst rows = normalizeList(all);\n\n// 8) Sem dados → erro padrão (com query e errors)\nif (rows.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação', query, errors: [] } }];\n}\n\nconst usage_gpt = safeGetUsage();\n\n// 9) OK: retorna SEMPRE { data, query, errors: [] }\nreturn [{ json: { data: rows, query, errors: [], tokensGeradorQuery: usage_gpt } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        576
      ],
      "id": "00d65088-4534-45b4-bfe8-8306dd83c4cf",
      "name": "Repassar dados"
    },
    {
      "parameters": {
        "jsCode": "// Entrada: { sql: \"SELECT ...\", userPrompt: \"...\" }  (ajuste nomes se preciso)\nlet sql = ($('Extract SQL query').first().json.query || \"\").trim();\n\n// 1) Remove comentários (-- e /* */) e normaliza espaços\nconst stripComments = s => {\n  // remove /* ... */ (multilinha)\n  s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, ' ');\n  // remove -- até o fim da linha\n  s = s.replace(/--.*$/gm, ' ');\n  return s;\n};\n\n/**\n * Sanitiza a SQL corrigindo problemas de sintaxe conhecidos\n * (COUNT() vazio e extract(year FROM ...)12 sem \"*\").\n *\n * A ideia é semelhante ao stripComments: recebe a string e\n * devolve a string sanitizada de uma vez só.\n */\nconst sanitizeSql = s => {\n  let out = s;\n\n  // 1) Corrige COUNT() → COUNT(*)\n  //    - pega qualquer COUNT(   ) possivelmente com espaços\n  out = out.replace(/COUNT\\s*\\(\\s*\\)/gi, 'COUNT(*)');\n\n  // 2) Corrige extract(year FROM algo)12 → extract(year FROM algo)*12\n  //    - captura o conteúdo dentro de year FROM ... )\n  //    - permite espaços variados\n  out = out.replace(\n    /extract\\s*\\(\\s*year\\s+from\\s+([^)]+)\\)\\s*12/gi,\n    'extract(year FROM $1)*12'\n\n  );\n\n  return out;\n};\n\nconst cleaned = stripComments(sql).replace(/\\s+/g, ' ').trim();\n\n\nconst forbidden = /\\b(SOMENTE|INSERT|UPDATE|DELETE|MERGE|CREATE|ALTER|DROP|TRUNCATE|GRANT|REVOKE|COMMENT|VACUUM|COPY|REFRESH|CALL|DO|BEGIN|COMMIT|ROLLBACK|SET|LOCK|CLUSTER|REINDEX|DISCARD)\\b/i;\nif (forbidden.test(cleaned)) {\n  return [{ \n    allowed: false,\n    reason: \"Contém comando proibido.\", \n    erro: `Somente SELECT é permitido. Não posso executar DDL/DML.\n    Detalhes: ` + $input.first().json.output\n  }];\n}\n\nlet sqlSanitized = sanitizeSql(sql);\n\nreturn [{ allowed: true, sql: sqlSanitized }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        320
      ],
      "id": "3867c7b3-e9c0-449e-a5a5-7ebe6ef3280c",
      "name": "Extrair query"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const msg = $json.output\n                 .flatMap(item => item.content || [])\n                 .filter(c => c.type === \"output_text\")\n                 .map(c => c.text)[0];   \nreturn {\n  json: {\n      erro: msg ?? \"Por favor, forneça a consulta ou pergunta específica que deseja realizar com base no esquema fornecido.\"\n  }\n};\n\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1376,
        464
      ],
      "id": "cfed2ef4-776f-4f6c-b8bd-51fcf950d118",
      "name": "Mensagem de query inválida"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Run Once for Each Item\n/**\n const msg = \"Solicitação contém comando proibido, somente SELECT é permitido. Não posso executar DDL/DML.\";\n */\nconst msg = $json.erro;\nreturn {\n  json: { erro: msg }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        384
      ],
      "id": "44f125e8-b188-4a19-a0f6-6bcd37276034",
      "name": "Mensagem de query Proibida"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.item;\nconst j = item.json;\n\nconst configuracaoPorCliente = {\n  \"0001\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"52.45.149.188\",\n    bancodedados: \"icommercial_faturamento_teste_luis\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"3738\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"52.45.149.188\",\n    bancodedados: \"icommercial_faturamento_teste_luis\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"testedev2\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"rabbitmq.icommercial002.inovamobil.com.br\",\n    bancodedados: \"icommercial_faturamento_testedev2\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"teste1\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"rabbitmq.icommercial001.inovamobil.com.br\",\n    bancodedados: \"icommercial_faturamento_teste1\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n};\n\n// ==== OBRIGATÓRIO TER código do IManager ====\nconst codigoIManager = (j.CodigoIManager ?? \"\");\nconst selected = configuracaoPorCliente[codigoIManager];\nif (!selected) {\n  throw new Error(\n    `Cliente ` + codigoIManager + ` não informado, favor validar para utilização do módulo.`\n  );\n}\n\nj.configuracao = {\n    host: selected.servidor,\n    database: selected.bancodedados,\n    user: selected.usuario,\n    password: selected.senha,\n    port: selected.porta,\n  };\n\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -192,
        432
      ],
      "id": "03ab7853-85c0-4a51-80bf-30dffdb04b67",
      "name": "Constantes"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/responses",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer ***MASKED_SECRET***"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"gpt-4.1-mini\",\n  \"temperature\": 0.2,\n  \"input\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Você é um GERADOR DE SQL para PostgreSQL guiado por um JSON de esquema chamado SCHEMA. Seu objetivo é produzir UMA ÚNICA consulta SELECT 100% válida, segura e fiel ao SCHEMA — sem inventar nada.\\n\\n====================================================================\\nEXEMPLO GUIADO (NÃO REPITA NA RESPOSTA FINAL)\\nExemplo de uso correto para pedidos de 3 meses consecutivos:\\nPEDIDO_EXEMPLO:\\n\\\"Liste todas as ligações que tiveram por 3 meses consecutivos no ano de 2025 a ocorrência LEITURA FORA DE FAIXA. Preciso que exiba o código da ligação, as referências e o código da ocorrência.\\\"\\n\\nRESPOSTA_EXEMPLO (SQL CORRETA):\\nWITH base AS (\\n  SELECT DISTINCT\\n    ul.\\\"UC_Lig_Id\\\",\\n    ul.\\\"UC_Leit_Ocorrencia_1\\\" AS ocorrencia_codigo,\\n    to_date(ul.\\\"UC_Leit_Mes_Ano\\\", 'MM/YYYY') AS ref_date\\n  FROM \\\"UC_Leitura\\\" ul\\n  JOIN \\\"Ocorrencias\\\" o\\n    ON o.\\\"Oco_Codigo\\\" = ul.\\\"UC_Leit_Ocorrencia_1\\\"\\n  WHERE\\n    o.\\\"Oco_Descricao\\\" ILIKE 'LEITURA FORA DE FAIXA'\\n    AND to_date(ul.\\\"UC_Leit_Mes_Ano\\\", 'MM/YYYY') >= DATE '2025-01-01'\\n    AND to_date(ul.\\\"UC_Leit_Mes_Ano\\\", 'MM/YYYY') < DATE '2026-01-01'\\n),\\nseq AS (\\n  SELECT\\n    b.\\\"UC_Lig_Id\\\",\\n    b.ocorrencia_codigo,\\n    b.ref_date,\\n    row_number() OVER (PARTITION BY b.\\\"UC_Lig_Id\\\" ORDER BY b.ref_date) AS rn,\\n    (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\\n      - row_number() OVER (PARTITION BY b.\\\"UC_Lig_Id\\\" ORDER BY b.ref_date) AS grp\\n  FROM base b\\n),\\nruns AS (\\n  SELECT\\n    \\\"UC_Lig_Id\\\",\\n    ocorrencia_codigo,\\n    grp,\\n    MIN(ref_date) AS ref1,\\n    COUNT(*) AS len\\n  FROM seq\\n  GROUP BY\\n    \\\"UC_Lig_Id\\\", ocorrencia_codigo, grp\\n  HAVING COUNT(*) >= 3\\n)\\nSELECT\\n  \\\"UC_Lig_Id\\\" AS \\\"Codigo_Ligacao\\\",\\n  to_char(ref1, 'MM/YYYY') AS \\\"Referencia_1\\\",\\n  to_char(ref1 + INTERVAL '1 month', 'MM/YYYY') AS \\\"Referencia_2\\\",\\n  to_char(ref1 + INTERVAL '2 month', 'MM/YYYY') AS \\\"Referencia_3\\\",\\n  ocorrencia_codigo AS \\\"Codigo_Ocorrencia\\\"\\nFROM runs\\nORDER BY \\\"Codigo_Ligacao\\\", \\\"Referencia_1\\\";\\n\\nFIM DO EXEMPLO.\\nUSE ESTE ESTILO COMO REFERÊNCIA.\\n====================================================================\\n\\nREGRAS PRIORITÁRIAS (NÃO PODE DESCUMPRIR)\\n1) É PROIBIDO usar COUNT(). SEMPRE use COUNT(*).\\n2) É PROIBIDO escrever extract(year FROM algo)12. SEMPRE escreva extract(year FROM algo)*12.\\n3) Se o PEDIDO falar de “3 meses consecutivos”, “3 leituras seguidas”, “3 faturas consecutivas” ou equivalente, você DEVE usar a fórmula:\\n   (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\\n   - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\\n\\nSe qualquer uma dessas regras for violadas na sua consulta, você NÃO pode retorná-la.\\nEm vez disso, responda apenas:\\n\\\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\\\"\\n\\n====================================================================\\n\\nENTRADAS\\n- SCHEMA: objeto JSON (⦃schema⦄) com:\\n  • tabelas[*].nome\\n  • tabelas[*].colunas[*].nome, tipo, pk?, fk?\\n  • relacionamentos[] (from=\\\"A.x\\\", to=\\\"B.y\\\")\\n  • regras.periodo_MMYYYY, regras.streak_MMYYYY, regras.sql_lints,\\n    regras.required_patterns, regras.templates, regras.sql_rewrites (se existirem)\\n- PEDIDO: descrição do que o usuário quer consultar (⦃pedido⦄).\\n\\n====================================================================\\nFONTES DE VERDADE\\n1) SCHEMA.tabelas/colunas\\n2) Relacionamentos explícitos (FKs ou SCHEMA.relacionamentos)\\n3) “regras.*” do SCHEMA (SE EXISTIREM) são obrigatórias.\\n\\nSe algo não existir no SCHEMA, considere que NÃO existe: explique e NÃO gere SQL.\\n\\n====================================================================\\nREGRAS GERAIS\\n- Gere apenas SELECT (pode conter WITH). Nunca gere UPDATE, DELETE, INSERT, CREATE, DROP, etc.\\n- Use somente tabelas/colunas existentes no SCHEMA.\\n- JOINS só podem ser feitos quando existe um relacionamento válido.\\n- Identificadores SEMPRE entre aspas duplas \\\"…\\\".\\n- Strings SEMPRE com aspas simples '…'.\\n- Nunca use SELECT *.\\n- COUNT(*) sempre que precisar contar.\\n- Nunca invente colunas ou tabelas.\\n\\n====================================================================\\nPERÍODO MM/YYYY (OBRIGATÓRIO se aplicável)\\nSe existir SCHEMA.regras.periodo_MMYYYY para a coluna usada:\\n- Para filtrar por ano (ex.: 2025), use:\\n  to_date(coluna, 'MM/YYYY') >= DATE '{{ano}}-01-01'\\n  AND to_date(coluna, 'MM/YYYY') < DATE '{{ano_next}}-01-01'\\n\\n- É PROIBIDO usar LIKE ou ILIKE em coluna MM/YYYY.\\n\\n====================================================================\\n3 MESES CONSECUTIVOS (streak_MMYYYY)\\nSempre que o PEDIDO mencionar:\\n- \\\"3 meses consecutivos\\\", \\\"3 leituras seguidas\\\",\\n- \\\"3 leituras consecutivas\\\", \\\"3 faturas seguidas\\\", etc.\\n\\nVocê DEVE aplicar o método padrão baseado em row_number():\\nWITH base (...)\\nWITH seq (...)\\nWITH runs (...)\\nRespeitando:\\n- row_number() OVER (PARTITION BY pid ORDER BY ref_date)\\n- Fórmula obrigatória:\\n  (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\\n  - row_number() OVER (...)\\n\\n- HAVING COUNT(*) >= 3 (ou min_streak_default)\\n\\n====================================================================\\nUSO DE TEMPLATES DO SCHEMA\\nSe SCHEMA.regras.templates.tres_meses_consecutivos_generico existir:\\n- Você DEVE usar o template como base\\n- Só pode alterar placeholders:\\n  {{padrao}}, {{ano}}, {{ano_next}}\\n\\n====================================================================\\nREGRAS DE REWRITES E REQUIRED PATTERNS\\nSe SCHEMA.regras.sql_rewrites existir:\\n- Aplique as substituições obrigatórias\\nDepois valide required_patterns.\\n\\n====================================================================\\nCHECKLIST FINAL (AUTO-CHECAGEM)\\nAntes de retornar a query, confirme:\\n1) NÃO contém COUNT()\\n2) NÃO contém extract(year FROM …)12\\n3) NÃO usa LIKE/ILIKE em colunas MM/YYYY\\n4) Se for streak:\\n   - row_number() obrigatório\\n   - fórmula obrigatória\\n   - HAVING COUNT(*)\\n\\nSe falhar:  \\n\\\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\\\"\\n\\n====================================================================\\nREGRA ADICIONAL 1 (CLIENTE = LIGAÇÃO)\\nQuando o PEDIDO mencionar “clientes” mas o SCHEMA não tiver relação 1:1 entre cliente e ligação:\\n- Considere UC_Lig_Id como identificador do “cliente”.\\n- NÃO use Pes_Codigo, a menos que o pedido explicitamente peça dados da pessoa.\\n- Streaks, agrupamentos, contagens percentuais e indicadores devem ser feitos por ligação.\\n\\n====================================================================\\nREGRA ADICIONAL 2 (CATEGORIA DA LIGAÇÃO)\\nQuando o PEDIDO envolver categoria da ligação (Residencial, Comercial, Industrial, etc.):\\n- A categoria “normal” da ligação usa SEMPRE o catálogo vCategoria (1=Residencial, 2=Comercial, 3=Industrial, 4=Publica, 5=Outros).\\n- Você pode obter essa categoria a partir de:\\n  • UC_Categoria.UC_Cat_Categoria → vCategoria\\n  • UC_Leitura_Categoria.UC_LeitCat_Categoria → vCategoria\\n- Use UC_Categoria quando a pergunta for sobre a categoria ATUAL da ligação.\\n- Use UC_Leitura_Categoria quando a pergunta estiver ligada a leituras/faturas em um período (ex.: “em 2025”).\\n- Nunca use campos ligados a vTipoCategoriaRecalculo para responder perguntas sobre a categoria “normal” da ligação.\\n\\n====================================================================\\nREGRA ADICIONAL 3 (LEITURAS ESTIMADAS)\\nQuando o PEDIDO falar de “leituras estimadas” ou “consumo estimado”:\\n\\n- Uma leitura é considerada ESTIMADA quando, para a ligação (UC_Lig_Id) associada:\\n\\n  1) A ligação NÃO possui hidrômetro ativo:\\n     NÃO deve existir registro em \\\"UC_Hidrometro\\\" com:\\n        • \\\"UC_Hidrometro\\\".\\\"UC_Lig_Id\\\" = \\\"UC_Leitura\\\".\\\"UC_Lig_Id\\\"\\n        • \\\"UC_Hidrometro\\\".\\\"UC_Hid_Ativo\\\" = TRUE\\n\\n  2) E existir registro em \\\"UC_Parametros\\\" com:\\n        • \\\"UC_Parametros\\\".\\\"UC_Lig_Id\\\" = \\\"UC_Leitura\\\".\\\"UC_Lig_Id\\\"\\n        • \\\"UC_Parametros\\\".\\\"UC_Par_Consumo_Estimado\\\" > 0\\n\\n- Para calcular quantidade ou taxa de leituras estimadas:\\n  • Trate TODAS as leituras da ligação que satisfazem essas duas condições como “estimadas”.\\n  • NÃO use apenas campos como \\\"UC_Leit_Leitura_Calculada\\\" para identificar estimadas.\\n\\n====================================================================\\nREGRA ADICIONAL 4 (CÁLCULO DE TAXA PERCENTUAL)\\nQuando precisar calcular uma taxa percentual (por exemplo, taxa de leituras estimadas por rota):\\n\\n- PRIMEIRO faça uma agregação em um nível (por exemplo, por rota), calculando:\\n  • COUNT(*)            AS total_registros\\n  • COUNT(*) FILTER (WHERE <condicao>) AS quantidade_com_condicao\\n\\n- SÓ DEPOIS, em um SELECT externo (ou CTE), calcule o percentual usando EXATAMENTE o padrão:\\n\\n  ROUND(\\n    CASE\\n      WHEN total_registros = 0 THEN 0\\n      ELSE quantidade_com_condicao::numeric / total_registros::numeric * 100\\n    END\\n  , 2) AS nome_da_taxa\\n\\n- Evite montar expressões muito longas com CASE + COUNT(*) FILTER aninhados diretamente na mesma camada do GROUP BY, para reduzir erros de parênteses.\\n- Sempre que possível, use:\\n  • um CTE de agregação (ex.: agg_por_rota)\\n  • e um SELECT final apenas para calcular a taxa a partir de total_registros e quantidade_com_condicao.\\n====================================================================\\nFORMATO DE RESPOSTA\\n- Se tudo estiver correto → retorne somente a SQL final.\\n- Se violar qualquer regra → retorne:\\n  \\\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\\\"\\n \\n\\n====================================================================\\nFORMATO DE RESPOSTA (OBRIGATÓRIO)\\n- Retorne SOMENTE a SQL pura.\\n- NÃO use markdown.\\n- NÃO use blocos ```sql ou ``` de nenhum tipo.\\n- NÃO coloque prefixos como \\\"SQL:\\\" ou \\\"Consulta:\\\".\\n- A resposta final deve ser EXATAMENTE uma string contendo apenas a query.\\n====================================================================\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.chatinput }}\"\n    }\n  ],\n  \"tools\": [\n    {\n      \"type\": \"file_search\",\n      \"vector_store_ids\": [\n        \"vs_691c57ff708881918d5932b6aaab6139\"\n      ]\n    }\n  ],\n  \"max_output_tokens\": 5000\n}\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        688,
        448
      ],
      "id": "24700b6c-a730-45f7-aff3-40d98580e8f4",
      "name": "GPT gerar query"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ebbe194a-4b8b-44c9-ac19-03cf69d353bf",
              "name": "query",
              "type": "string",
              "value": "={{ ($json.output[1].content[0].text) }}"
            },
            {
              "id": "31051a50-6a54-4191-aa25-df9aaf53c4d7",
              "name": "",
              "value": "",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "536e3b71-540a-476b-80d2-d758245ffd4c",
      "name": "Extract SQL query",
      "type": "n8n-nodes-base.set",
      "position": [
        912,
        448
      ],
      "typeVersion": 3.4
    }
  ],
  "connections": {
    "Download file": {
      "main": [
        [
          {
            "node": "Extract data from file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if query exists": {
      "main": [
        [
          {
            "node": "Extrair query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mensagem de query inválida",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine schema data and chat input": {
      "main": [
        [
          {
            "node": "GPT gerar query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        []
      ]
    },
    "Extract data from file": {
      "main": [
        [
          {
            "node": "Combine schema data and chat input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Window Buffer Memory1": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Setar informações de Parâmetros": {
      "main": [
        [
          {
            "node": "Constantes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entrada": {
      "main": [
        [
          {
            "node": "Setar informações de Parâmetros",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        []
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mensagem de query Proibida",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Repassar dados": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extrair query": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mensagem de query inválida": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mensagem de query Proibida": {
      "main": [
        [
          {
            "node": "Repassar dados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Constantes": {
      "main": [
        [
          {
            "node": "Download file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT gerar query": {
      "main": [
        [
          {
            "node": "Extract SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract SQL query": {
      "main": [
        [
          {
            "node": "Check if query exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "4bbd582e-3688-4a60-878e-8da8b493248b",
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-09-08T19:14:20.116Z",
      "createdAt": "2025-09-08T19:14:20.116Z",
      "role": "workflow:owner",
      "workflowId": "NNGADr1RKcWgUpJj",
      "projectId": "bDUBly1zU3yziLIn"
    }
  ],
  "tags": []
}