{"createdAt":"2025-09-08T19:14:20.112Z","updatedAt":"2025-11-12T17:26:30.000Z","id":"NNGADr1RKcWgUpJj","name":"Datamobil - VX Embedded - Produção","active":true,"isArchived":false,"nodes":[{"parameters":{"operation":"download","fileId":{"__rl":true,"value":"1Me1e3qR3ZqwJO6TQvowfBmmaocjsp3-b","mode":"list","cachedResultName":"SFC_WEB_Completo.json","cachedResultUrl":"https://drive.google.com/file/d/1Me1e3qR3ZqwJO6TQvowfBmmaocjsp3-b/view?usp=drivesdk"},"options":{"binaryPropertyName":"json"}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[48,432],"id":"eceb052d-2c16-4cba-b74a-e4e2068d9b39","name":"Download file","credentials":{"googleDriveOAuth2Api":{"id":"A7dItjE7OWcTVPSQ","name":"Google Drive account"}}},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"id":"5f3b3c30-78e9-4ed0-b520-9153664540ec","leftValue":"={{ $json.query }}","rightValue":"SELECT","operator":{"type":"string","operation":"contains"}}],"combinator":"and"},"options":{}},"id":"fbb4885e-831f-4523-8d31-ce394fb5a1b0","name":"Check if query exists","type":"n8n-nodes-base.if","position":[1136,448],"typeVersion":2.2},{"parameters":{"assignments":{"assignments":[{"id":"ebbe194a-4b8b-44c9-ac19-03cf69d353bf","name":"query","type":"string","value":"={{ ($json.output) }}"}]},"includeOtherFields":true,"options":{}},"id":"5cfb2fe2-fb53-4866-bb6e-03ae6893c66d","name":"Extract SQL query","type":"n8n-nodes-base.set","position":[976,448],"typeVersion":3.4},{"parameters":{"assignments":{"assignments":[{"id":"42abd24e-419a-47d6-bc8b-7146dd0b8314","name":"sessionId","type":"string","value":"={{ $('Entrada').item.json.query.CNPJ }}"},{"id":"f78c57d9-df13-43c7-89a7-5387e528107e","name":"chatinput","type":"string","value":"={{ $('Entrada').item.json.query.Solicitacao }}"},{"id":"e42b39eb-dfbd-48d9-94ed-d658bdd41454","name":"schema","type":"string","value":"={{ $json.json }}"}]},"options":{}},"id":"45b8dafb-379d-4180-a923-7a8b9b5b9e85","name":"Combine schema data and chat input","type":"n8n-nodes-base.set","position":[448,432],"executeOnce":true,"typeVersion":3.4},{"parameters":{"promptType":"define","text":"=Here is the database schema: {{ $json.schema }}\nHere is the user request: {{ $json.chatinput }}","options":{"systemMessage":"Você é um GERADOR DE SQL para PostgreSQL guiado por um JSON de esquema chamado SCHEMA.\nSeu objetivo é produzir UMA ÚNICA consulta SELECT 100% válida, segura e fiel ao SCHEMA — sem inventar nada.\n\n====================================================================\nEXEMPLO GUIADO (NÃO REPITA NA RESPOSTA FINAL)\n\nExemplo de uso correto para pedidos de 3 meses consecutivos:\n\nPEDIDO_EXEMPLO:\n\"Liste todas as ligações que tiveram por 3 meses consecutivos no ano de 2025\n a ocorrência LEITURA FORA DE FAIXA. Preciso que exiba o código da ligação,\n as referências e o código da ocorrência.\"\n\nRESPOSTA_EXEMPLO (SQL CORRETA):\n\nWITH base AS (\n  SELECT DISTINCT\n    ul.\"UC_Lig_Id\",\n    ul.\"UC_Leit_Ocorrencia_1\" AS ocorrencia_codigo,\n    to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') AS ref_date\n  FROM \"UC_Leitura\" ul\n  JOIN \"Ocorrencias\" o\n    ON o.\"Oco_Codigo\" = ul.\"UC_Leit_Ocorrencia_1\"\n  WHERE\n    o.\"Oco_Descricao\" ILIKE 'LEITURA FORA DE FAIXA'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') >= DATE '2025-01-01'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') <  DATE '2026-01-01'\n),\nseq AS (\n  SELECT\n    b.\"UC_Lig_Id\",\n    b.ocorrencia_codigo,\n    b.ref_date,\n    row_number() OVER (\n      PARTITION BY b.\"UC_Lig_Id\"\n      ORDER BY b.ref_date\n    ) AS rn,\n    (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n      - row_number() OVER (\n          PARTITION BY b.\"UC_Lig_Id\"\n          ORDER BY b.ref_date\n        ) AS grp\n  FROM base b\n),\nruns AS (\n  SELECT\n    \"UC_Lig_Id\",\n    ocorrencia_codigo,\n    grp,\n    MIN(ref_date) AS ref1,\n    COUNT(*) AS len\n  FROM seq\n  GROUP BY\n    \"UC_Lig_Id\",\n    ocorrencia_codigo,\n    grp\n  HAVING COUNT(*) >= 3\n)\nSELECT\n  \"UC_Lig_Id\" AS \"Codigo_Ligacao\",\n  to_char(ref1, 'MM/YYYY') AS \"Referencia_1\",\n  to_char(ref1 + INTERVAL '1 month', 'MM/YYYY') AS \"Referencia_2\",\n  to_char(ref1 + INTERVAL '2 month', 'MM/YYYY') AS \"Referencia_3\",\n  ocorrencia_codigo AS \"Codigo_Ocorrencia\"\nFROM runs\nORDER BY\n  \"Codigo_Ligacao\",\n  \"Referencia_1\";\n\nFIM DO EXEMPLO. USE ESTE ESTILO COMO REFERÊNCIA.\n====================================================================\n\nREGRAS PRIORITÁRIAS (NÃO PODE DESCUMPRIR)\n\n1) É PROIBIDO usar COUNT().\n   SEMPRE use COUNT(*).\n\n2) É PROIBIDO escrever extract(year FROM algo)12.\n   SEMPRE escreva extract(year FROM algo)*12.\n\n3) Se o PEDIDO falar de “3 meses consecutivos”, “3 leituras seguidas”,\n   “3 faturas consecutivas” ou equivalente, você DEVE usar a fórmula:\n\n   (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n     - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n\nSe qualquer uma dessas regras for violada na sua consulta, você NÃO pode retorná-la.\nEm vez disso, responda apenas:\n\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n====================================================================\nENTRADAS\n\n- SCHEMA: objeto JSON (⦃schema⦄) com:\n  • tabelas[*].nome\n  • tabelas[*].colunas[*].nome, .tipo, .pk?, .fk?\n  • relacionamentos[] (from=\"A.x\", to=\"B.y\")\n  • regras.periodo_MMYYYY, regras.streak_MMYYYY,\n    regras.sql_lints, regras.required_patterns,\n    regras.templates, regras.sql_rewrites (se existirem)\n\n- PEDIDO: descrição do que o usuário quer consultar (⦃pedido⦄).\n\n====================================================================\nFONTES DE VERDADE\n\n1) SCHEMA.tabelas/colunas\n2) Relacionamentos explícitos (FKs ou SCHEMA.relacionamentos)\n3) “regras.*” do SCHEMA (SE EXISTIREM) são obrigatórias.\n\nSe algo não existir no SCHEMA, considere que NÃO existe:\nexplique e NÃO gere SQL.\n\n====================================================================\nREGRAS GERAIS\n\n- Gere apenas SELECT (inclui WITH … SELECT).\n  Se pedirem DDL ou DML (CREATE, UPDATE, DELETE, INSERT, DROP, etc.),\n  responda: \"Somente SELECT é permitido.\" e NÃO gere SQL.\n\n- Use apenas tabelas/colunas do SCHEMA.\n\n- JOINS só com relacionamento em alguma fonte (FK ou SCHEMA.relacionamentos).\n  Se não houver caminho de join entre as tabelas solicitadas, explique e NÃO gere SQL.\n\n- Identificadores SEMPRE entre aspas duplas \"…\".\n- Strings SEMPRE com aspas simples '…'.\n\n- Nunca use SELECT *; projete apenas as colunas necessárias.\n- Contagens SEMPRE com COUNT(*).\n\n====================================================================\nPERÍODO MM/YYYY (OBRIGATÓRIO se aplicável)\n\nSe existir SCHEMA.regras.periodo_MMYYYY para a coluna pedida\n(ex.: \"UC_Leitura\".\"UC_Leit_Mes_Ano\"):\n\n- Para filtrar por ano (ex.: 2025), use SEMPRE:\n\n  to_date(coluna, 'MM/YYYY') >= DATE '{{ano}}-01-01'\n  AND to_date(coluna, 'MM/YYYY') <  DATE '{{ano_next}}-01-01'\n\n- É PROIBIDO usar LIKE ou ILIKE para filtrar colunas MM/YYYY cobertas por periodo_MMYYYY.\n  Use SEMPRE to_date(coluna, 'MM/YYYY') e comparação por intervalo de datas.\n\n====================================================================\n3 MESES CONSECUTIVOS (streak_MMYYYY)\n\nSempre que o PEDIDO mencionar:\n\n- \"3 meses consecutivos\", \"3 leituras seguidas\", \"3 leituras consecutivas\",\n- \"3 faturas seguidas\", \"3 referências consecutivas\" ou equivalente,\n\nvocê DEVE aplicar SCHEMA.regras.streak_MMYYYY (se existir).\n\nSe SCHEMA.regras.streak_MMYYYY.metodo = \"row_number_gap\", use:\n\n- pid  = SCHEMA.regras.streak_MMYYYY.pid\n- data = cast = SCHEMA.regras.streak_MMYYYY.cast\n\nPadrão geral:\n\nWITH base AS (\n    SELECT DISTINCT\n        {{pid}}      AS pid,\n        {{cast}}     AS ref_date,\n        -- outras colunas necessárias ao PEDIDO\n        ...\n    FROM <tabela_principal>\n    -- joins conforme relacionamentos do SCHEMA\n    ...\n    WHERE\n        -- filtros do PEDIDO (ex.: ocorrência, ano, etc.)\n        ...\n),\nseq AS (\n    SELECT\n        b.pid,\n        b.ref_date,\n        ...,\n        row_number() OVER (\n            PARTITION BY b.pid\n            ORDER BY b.ref_date\n        ) AS rn,\n        (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n          - row_number() OVER (\n                PARTITION BY b.pid\n                ORDER BY b.ref_date\n            ) AS grp\n    FROM base b\n),\nruns AS (\n    SELECT\n        pid,\n        MIN(ref_date) AS ref1,\n        COUNT(*)      AS len\n    FROM seq\n    GROUP BY pid, grp\n    HAVING COUNT(*) >= COALESCE(SCHEMA.regras.streak_MMYYYY.min_streak_default, 3)\n)\n\nSELECT\n    ...\nFROM runs\n...\n\nRESTRIÇÕES PARA STREAK:\n\n- É PROIBIDO usar LEAD(ref_label) ou auto-join por + INTERVAL '1 month' entre linhas.\n- É OBRIGATÓRIO usar a fórmula do grupo:\n\n  (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n    - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n\n- É OBRIGATÓRIO usar COUNT(*) (nunca COUNT()) no agrupamento de streak.\n\n====================================================================\nUSO DO TEMPLATE DE 3 MESES (SE EXISTIR NO SCHEMA)\n\nSe SCHEMA.regras.templates.tres_meses_consecutivos_generico existir\nE o PEDIDO falar de:\n\n- \"3 meses consecutivos\", \"três meses seguidos\",\n- \"3 leituras consecutivas\", \"3 faturas seguidas\", etc.,\n\nENTÃO:\n\n1) Você NÃO DEVE inventar a query do zero.\n2) Você DEVE usar o SQL de\n   SCHEMA.regras.templates.tres_meses_consecutivos_generico\n   como base.\n\n3) A ÚNICA coisa que você pode alterar são os placeholders:\n\n   - {{padrao}}   → string da ocorrência pedida\n     ex.: 'LEITURA FORA DE FAIXA'\n   - {{ano}}      → ano pedido (ex.: 2025).\n   - {{ano_next}} → ano seguinte (ex.: 2026).\n\n4) É PROIBIDO mudar QUALQUER OUTRA PARTE da query do template:\n\n   - Não mude a fórmula com extract(year FROM ...)*12.\n   - Não mude COUNT(*) para COUNT().\n   - Não mude a estrutura das CTEs (base, seq, runs).\n\n====================================================================\nUSO DE regras.sql_rewrites E regras.required_patterns\n\nSe SCHEMA.regras.sql_rewrites existir, trate-as como um pós-processamento mental\nOBRIGATÓRIO da sua query antes de responder:\n\n- Para cada regra em SCHEMA.regras.sql_rewrites:\n  • Se o padrão da sua query corresponder ao match_regex\n    (por exemplo, COUNT() vazio, ou extract(year ... )12 sem \"*\"),\n    você deve REESCREVER a consulta para usar o texto replace da regra\n    (ex.: trocar COUNT() por COUNT(*), ou\n          (extract(year FROM ...))12 por (extract(year FROM ...)) * 12).\n\nDepois disso, verifique SCHEMA.regras.required_patterns (se existirem):\n\n- Cada item em SCHEMA.regras.required_patterns é um padrão OBRIGATÓRIO.\n- Ajuste a query até que TODOS esses padrões estejam presentes.\n- Para streak de 3 meses, padrões típicos incluem:\n  • row_number() OVER (PARTITION BY \"UC_Lig_Id\" ORDER BY ref_date)\n  • (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n  • HAVING COUNT(*) >= 3\n\nSe você não conseguir construir uma consulta que respeite TODAS as regras, NÃO gere SQL.\n\n====================================================================\nCHECKLIST FINAL (AUTO-CHECAGEM)\n\nAntes de responder, revise a SUA PRÓPRIA CONSULTA como texto:\n\n1) Verifique se NENHUM desses problemas aparece:\n   - \"COUNT()\"            (sem nada dentro)\n   - \"extract(year FROM\" seguido diretamente de \"12\" sem \"*\"\n   - LIKE/ILIKE em colunas MM/YYYY cobertas por periodo_MMYYYY\n\n2) Se o PEDIDO for de 3 meses consecutivos, verifique se a query contém:\n   - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n   - a fórmula do grupo com *12:\n     (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n       - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n   - HAVING COUNT(*) >= 3\n     (ou o valor de regras.streak_MMYYYY.min_streak_default, se existir)\n\n3) Se QUALQUER item da checagem falhar:\n   - NÃO gere SQL.\n   - Responda apenas:\n     \"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n4) Se tudo estiver OK:\n   - Você pode retornar a consulta SQL.\n\n====================================================================\nFORMATO DE RESPOSTA\n\n- Quando a auto-checagem passar:\n  • Retorne APENAS a consulta SQL final (sem comentários, sem JSON, sem explicações).\n\n- Quando a auto-checagem reprovar:\n  • Não retorne SQL.\n  • Responda apenas:\n    \"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n","maxIterations":1}},"id":"a39a4d0e-d6d2-4898-a9fa-359d3994ac63","name":"AI Agent","type":"@n8n/n8n-nodes-langchain.agent","position":[656,560],"typeVersion":1.6},{"parameters":{"operation":"fromJson","binaryPropertyName":"json","destinationKey":"json","options":{"encoding":"utf8"}},"id":"aa7febb9-ec73-446e-84af-c335abb20cc4","name":"Extract data from file","type":"n8n-nodes-base.extractFromFile","position":[256,432],"typeVersion":1},{"parameters":{"model":"gpt-5-mini","options":{"maxTokens":1024,"maxRetries":2}},"id":"8c6694ff-96f4-4798-a934-c26761d998b4","name":"OpenAI Chat Model1","type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","position":[656,768],"typeVersion":1,"credentials":{"openAiApi":{"id":"H4HnbIJCN7JE8cR5","name":"OpenAi account"}}},{"parameters":{"contextWindowLength":3},"id":"f658bf79-835e-486d-bf79-bac4c0b75eb4","name":"Window Buffer Memory1","type":"@n8n/n8n-nodes-langchain.memoryBufferWindow","position":[784,816],"typeVersion":1.2},{"parameters":{"operation":"executeQuery","query":"{{ $('Extract SQL query').item.json.query }}","options":{"connectionTimeout":180}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1824,224],"id":"082311bb-be8a-4165-ae0b-519b80286d5e","name":"Execute a SQL query","alwaysOutputData":true,"executeOnce":false,"credentials":{"postgres":{"id":"6iqsLXZTqf2rK4YA","name":"Postgres account"}},"onError":"continueRegularOutput"},{"parameters":{"assignments":{"assignments":[{"id":"b86f4807-aff3-42fb-a110-f43653368396","name":"Solicitacao","value":"={{ $json.query.Solicitacao }}","type":"string"},{"id":"66447438-499c-4ab3-88ee-e20835aa7618","name":"CodigoIManager","value":"={{ $json.query.CodigoIManager }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-432,432],"id":"405d26ac-9b05-4f31-9d58-ea05b09d36ec","name":"Setar informações de Parâmetros"},{"parameters":{"options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[2240,576],"id":"653cc375-23ca-4179-8959-14759f57acf2","name":"Respond to Webhook"},{"parameters":{"path":"datamobilIA","responseMode":"responseNode","options":{"binaryPropertyName":"data","responseHeaders":{"entries":[{"name":"Solicitacao"},{"name":"CNPJ"},{"name":"CodigoManager"}]}}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[-688,432],"id":"8d7f940f-6005-4df8-bd10-02dc8933b7c5","name":"Entrada","webhookId":"4d110ba1-2fc6-4d65-810a-362b2d518210"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"f8f105fa-8e7c-4309-9cd9-9a5c987ed77f","leftValue":"={{ $json.allowed }}","rightValue":"","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[1520,320],"id":"faa155f3-664d-4905-b84a-4c4020bd17b9","name":"If1"},{"parameters":{"jsCode":"// Run Once for All Items\n\nconst items = $input.all();\n\n// --- Utils ------------------------------------------------------------------\n\nfunction hasMeaningfulContent(o, depth = 0) {\n  if (o == null) return false;\n  if (typeof o !== 'object') return String(o).trim() !== '';\n  if (depth > 6) return true;\n  if (Array.isArray(o)) return o.some(v => hasMeaningfulContent(v, depth + 1));\n  const keys = Object.keys(o);\n  if (keys.length === 0) return false;\n  return keys.some(k => hasMeaningfulContent(o[k], depth + 1));\n}\n\nfunction collectErrorsDeep(obj, found = []) {\n  if (obj == null) return found;\n\n  const pushErr = (val) => {\n    if (val == null) return;\n    const msg = typeof val === 'object' ? JSON.stringify(val) : String(val);\n    if (msg.trim()) found.push(msg.trim());\n  };\n\n  if (Array.isArray(obj)) {\n    for (const v of obj) collectErrorsDeep(v, found);\n    return found;\n  }\n\n  if (typeof obj === 'object') {\n    for (const [k, v] of Object.entries(obj)) {\n      const lower = k.toLowerCase();\n      if (lower === 'erro' || lower === 'error') pushErr(v);\n      else if (lower === 'message' && typeof v === 'string') pushErr(v);\n      collectErrorsDeep(v, found);\n    }\n    return found;\n  }\n\n  return found;\n}\n\nfunction dedupStrings(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const s of arr) if (!seen.has(s)) { seen.add(s); out.push(s); }\n  return out;\n}\n\n// Preferência do Luis: $json.message.content.data\nfunction extractUsefulPayload(j) {\n  if (Array.isArray(j?.message?.content?.data)) return j.message.content.data.slice();\n  if (Array.isArray(j?.data)) return j.data.slice();\n  if (hasMeaningfulContent(j)) return [j];\n  return [];\n}\n\nfunction normalizeList(list) {\n  return list\n    .map(x => (x?.json ?? x))\n    .filter(o => hasMeaningfulContent(o))\n    .map(o => (typeof o === 'object' ? o : { value: o }));\n}\n\n// Captura a query de forma resiliente (suporta Set, Function e mesmo payload)\nfunction safeGetQuery() {\n  // 1) Se a query veio nos itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const q = j.query ?? j.sql ?? j.consulta;\n    if (typeof q === 'string' && q.trim()) return q.trim();\n  }\n\n  // 2) Caso a query esteja em outro nó do fluxo\n  try {\n    // Altere o nome abaixo para o nó onde a SQL é montada (ex: \"Extract SQL query\" ou \"Montar Query\")\n    const fromNode = $items('Extract SQL query', 0, 0);\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const q = j.query ?? j.sql ?? j.consulta;\n      if (typeof q === 'string' && q.trim()) return q.trim();\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null; // não encontrada\n}\n\n// --- Fluxo ------------------------------------------------------------------\n\n// 1) Sem entradas\nif (!items || items.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação' } }];\n}\n\n// 2) Procure erros em todo o payload bruto\nlet erros = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  collectErrorsDeep(j, erros);\n}\nerros = dedupStrings(erros);\n\n// 3) Se achou erro, retorna somente { Erro }\nif (erros.length > 0) {\n  return [{ json: { Erro: erros[0] } }];\n}\n\n// 4) Extrair dados dos formatos suportados\nlet all = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  all.push(...extractUsefulPayload(j));\n}\n\n// 5) Fallback: cada item.json\nif (all.length === 0) {\n  all = items.map(i => i?.json ?? {});\n}\n\n// 6) Checar erros dentro da lista\nlet innerErrors = [];\ncollectErrorsDeep(all, innerErrors);\ninnerErrors = dedupStrings(innerErrors);\nif (innerErrors.length > 0) {\n  return [{ json: { Erro: innerErrors[0] } }];\n}\n\n// 7) Limpeza de dados\nconst rows = normalizeList(all);\n\n// 8) Captura a query (sem quebrar se não existir)\nconst query = safeGetQuery();\n\n// 9) Sem dados → erro padrão\nif (rows.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação' } }];\n}\n\n// 10) OK: retorna SEMPRE { data, query }\nreturn [{ json: { data: rows, query } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2048,576],"id":"00d65088-4534-45b4-bfe8-8306dd83c4cf","name":"Repassar dados"},{"parameters":{"jsCode":"// Entrada: { sql: \"SELECT ...\", userPrompt: \"...\" }  (ajuste nomes se preciso)\nlet sql = ($('Extract SQL query').first().json.query || \"\").trim();\n\n// 1) Remove comentários (-- e /* */) e normaliza espaços\nconst stripComments = s => {\n  // remove /* ... */ (multilinha)\n  s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, ' ');\n  // remove -- até o fim da linha\n  s = s.replace(/--.*$/gm, ' ');\n  return s;\n};\n\n/**\n * Sanitiza a SQL corrigindo problemas de sintaxe conhecidos\n * (COUNT() vazio e extract(year FROM ...)12 sem \"*\").\n *\n * A ideia é semelhante ao stripComments: recebe a string e\n * devolve a string sanitizada de uma vez só.\n */\nconst sanitizeSql = s => {\n  let out = s;\n\n  // 1) Corrige COUNT() → COUNT(*)\n  //    - pega qualquer COUNT(   ) possivelmente com espaços\n  out = out.replace(/COUNT\\s*\\(\\s*\\)/gi, 'COUNT(*)');\n\n  // 2) Corrige extract(year FROM algo)12 → extract(year FROM algo)*12\n  //    - captura o conteúdo dentro de year FROM ... )\n  //    - permite espaços variados\n  out = out.replace(\n    /extract\\s*\\(\\s*year\\s+from\\s+([^)]+)\\)\\s*12/gi,\n    'extract(year FROM $1)*12'\n\n  );\n\n  return out;\n};\n\nconst cleaned = stripComments(sql).replace(/\\s+/g, ' ').trim();\n\n\nconst forbidden = /\\b(SOMENTE|INSERT|UPDATE|DELETE|MERGE|CREATE|ALTER|DROP|TRUNCATE|GRANT|REVOKE|COMMENT|VACUUM|COPY|REFRESH|CALL|DO|BEGIN|COMMIT|ROLLBACK|SET|LOCK|CLUSTER|REINDEX|DISCARD)\\b/i;\nif (forbidden.test(cleaned)) {\n  return [{ \n    allowed: false,\n    reason: \"Contém comando proibido.\", \n    erro: `Somente SELECT é permitido. Não posso executar DDL/DML.\n    Detalhes: ` + $input.first().json.output\n  }];\n}\n\nlet sqlSanitized = sanitizeSql(sql);\n\nreturn [{ allowed: true, sql: sqlSanitized }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1328,320],"id":"3867c7b3-e9c0-449e-a5a5-7ebe6ef3280c","name":"Extrair query"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Run Once for Each Item\n// devolve UM item por entrada (sem colchetes)\nconst msg = $json.output; \nreturn {\n  json: {\n      erro:msg ?? \"Por favor, forneça a consulta ou pergunta específica que deseja realizar com base no esquema fornecido.\"\n  }\n};\n\n\n\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1376,464],"id":"cfed2ef4-776f-4f6c-b8bd-51fcf950d118","name":"Mensagem de query inválida"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Run Once for Each Item\n/**\n const msg = \"Solicitação contém comando proibido, somente SELECT é permitido. Não posso executar DDL/DML.\";\n */\nconst msg = $json.erro;\nreturn {\n  json: { erro: msg }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1792,384],"id":"44f125e8-b188-4a19-a0f6-6bcd37276034","name":"Mensagem de query Proibida"},{"parameters":{"jsCode":"const item = $input.item;\nconst j = item.json;\n\nconst configuracaoPorCliente = {\n  \"0001\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"52.45.149.188\",\n    bancodedados: \"icommercial_faturamento_teste_luis\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"3738\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"52.45.149.188\",\n    bancodedados: \"icommercial_faturamento_teste_luis\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"testedev2\": {\n    CNPJ: $input.first().json.CNPJ,\n    servidor: \"rabbitmq.icommercial002.inovamobil.com.br\",\n    bancodedados: \"icommercial_faturamento_testedev2\",\n    usuario: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n};\n\n// ==== OBRIGATÓRIO TER código do IManager ====\nconst codigoIManager = (j.CodigoIManager ?? \"\");\nconst selected = configuracaoPorCliente[codigoIManager];\nif (!selected) {\n  throw new Error(\n    `Cliente ` + codigoIManager + ` não informado, favor validar para utilização do módulo.`\n  );\n}\n\nj.configuracao = {\n    host: selected.servidor,\n    database: selected.bancodedados,\n    user: selected.usuario,\n    password: selected.senha,\n    port: selected.porta,\n  };\n\nreturn item;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-192,432],"id":"03ab7853-85c0-4a51-80bf-30dffdb04b67","name":"Constantes"}],"connections":{"Download file":{"main":[[{"node":"Extract data from file","type":"main","index":0}]]},"Check if query exists":{"main":[[{"node":"Extrair query","type":"main","index":0}],[{"node":"Mensagem de query inválida","type":"main","index":0}]]},"Extract SQL query":{"main":[[{"node":"Check if query exists","type":"main","index":0}]]},"Combine schema data and chat input":{"main":[[{"node":"AI Agent","type":"main","index":0}]]},"AI Agent":{"main":[[{"node":"Extract SQL query","type":"main","index":0}]]},"Extract data from file":{"main":[[{"node":"Combine schema data and chat input","type":"main","index":0}]]},"OpenAI Chat Model1":{"ai_languageModel":[[{"node":"AI Agent","type":"ai_languageModel","index":0}]]},"Window Buffer Memory1":{"ai_memory":[[{"node":"AI Agent","type":"ai_memory","index":0}]]},"Execute a SQL query":{"main":[[{"node":"Repassar dados","type":"main","index":0}],[]]},"Setar informações de Parâmetros":{"main":[[{"node":"Constantes","type":"main","index":0}]]},"Entrada":{"main":[[{"node":"Setar informações de Parâmetros","type":"main","index":0}]]},"Respond to Webhook":{"main":[[]]},"If1":{"main":[[{"node":"Execute a SQL query","type":"main","index":0}],[{"node":"Mensagem de query Proibida","type":"main","index":0}]]},"Repassar dados":{"main":[[{"node":"Respond to Webhook","type":"main","index":0}]]},"Extrair query":{"main":[[{"node":"If1","type":"main","index":0}]]},"Mensagem de query inválida":{"main":[[{"node":"Repassar dados","type":"main","index":0}]]},"Mensagem de query Proibida":{"main":[[{"node":"Repassar dados","type":"main","index":0}]]},"Constantes":{"main":[[{"node":"Download file","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"ad049dd8-e616-4ee8-853d-2b22dc1a69eb","triggerCount":1,"shared":[{"createdAt":"2025-09-08T19:14:20.116Z","updatedAt":"2025-09-08T19:14:20.116Z","role":"workflow:owner","workflowId":"NNGADr1RKcWgUpJj","projectId":"bDUBly1zU3yziLIn"}],"tags":[]}