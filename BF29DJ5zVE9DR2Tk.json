{"createdAt":"2025-08-14T20:21:27.407Z","updatedAt":"2025-11-12T17:21:27.000Z","id":"BF29DJ5zVE9DR2Tk","name":"Datamobil - VX - Produção","active":true,"isArchived":false,"nodes":[{"parameters":{"operation":"download","fileId":{"__rl":true,"value":"1Me1e3qR3ZqwJO6TQvowfBmmaocjsp3-b","mode":"list","cachedResultName":"SFC_WEB_Completo.json","cachedResultUrl":"https://drive.google.com/file/d/1Me1e3qR3ZqwJO6TQvowfBmmaocjsp3-b/view?usp=drivesdk"},"options":{"binaryPropertyName":"json"}},"type":"n8n-nodes-base.googleDrive","typeVersion":3,"position":[-3824,-176],"id":"ea549f27-c1fe-429a-a7b1-cebfbed5fc4e","name":"Download file","credentials":{"googleDriveOAuth2Api":{"id":"A7dItjE7OWcTVPSQ","name":"Google Drive account"}}},{"parameters":{"conditions":{"options":{"version":2,"leftValue":"","caseSensitive":true,"typeValidation":"strict"},"conditions":[{"id":"5f3b3c30-78e9-4ed0-b520-9153664540ec","leftValue":"={{ $json.query }}","rightValue":"SELECT","operator":{"type":"string","operation":"contains"}},{"id":"30aa76bc-6ddc-4271-b030-c4f54c655f27","leftValue":"={{ $json.query }}","rightValue":"Olá","operator":{"type":"string","operation":"notContains"}}],"combinator":"and"},"options":{}},"id":"61d3c4f7-d24f-4e70-8b54-020e714ed0d3","name":"Check if query exists","type":"n8n-nodes-base.if","position":[-2736,-160],"typeVersion":2.2},{"parameters":{"assignments":{"assignments":[{"id":"ebbe194a-4b8b-44c9-ac19-03cf69d353bf","name":"query","type":"string","value":"={{ ($json.output) }}"}]},"includeOtherFields":true,"options":{}},"id":"79b7d1a9-6bd7-4c42-815b-61dd0fd85058","name":"Extract SQL query","type":"n8n-nodes-base.set","position":[-2896,-160],"typeVersion":3.4},{"parameters":{"assignments":{"assignments":[{"id":"f78c57d9-df13-43c7-89a7-5387e528107e","name":"chatinput","type":"string","value":"={{ $('When chat message received').item.json.chatInput }}"},{"id":"e42b39eb-dfbd-48d9-94ed-d658bdd41454","name":"schema","type":"string","value":"={{ $json.json }}"}]},"options":{}},"id":"0516bd6a-059d-4796-af1f-73026f6d4c55","name":"Combine schema data and chat input","type":"n8n-nodes-base.set","position":[-3424,-176],"executeOnce":true,"typeVersion":3.4},{"parameters":{"promptType":"define","text":"=Here is the database schema: {{ $json.schema }}\nHere is the user request: {{ $json.chatinput }}","options":{"systemMessage":"=Você é um GERADOR DE SQL para PostgreSQL guiado por um JSON de esquema chamado SCHEMA.\nSeu objetivo é produzir UMA ÚNICA consulta SELECT 100% válida, segura e fiel ao SCHEMA — sem inventar nada.\n\n====================================================================\nEXEMPLO GUIADO (NÃO REPITA NA RESPOSTA FINAL)\n\nExemplo de uso correto para pedidos de 3 meses consecutivos:\n\nPEDIDO_EXEMPLO:\n\"Liste todas as ligações que tiveram por 3 meses consecutivos no ano de 2025\n a ocorrência LEITURA FORA DE FAIXA. Preciso que exiba o código da ligação,\n as referências e o código da ocorrência.\"\n\nRESPOSTA_EXEMPLO (SQL CORRETA):\n\nWITH base AS (\n  SELECT DISTINCT\n    ul.\"UC_Lig_Id\",\n    ul.\"UC_Leit_Ocorrencia_1\" AS ocorrencia_codigo,\n    to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') AS ref_date\n  FROM \"UC_Leitura\" ul\n  JOIN \"Ocorrencias\" o\n    ON o.\"Oco_Codigo\" = ul.\"UC_Leit_Ocorrencia_1\"\n  WHERE\n    o.\"Oco_Descricao\" ILIKE 'LEITURA FORA DE FAIXA'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') >= DATE '2025-01-01'\n    AND to_date(ul.\"UC_Leit_Mes_Ano\", 'MM/YYYY') <  DATE '2026-01-01'\n),\nseq AS (\n  SELECT\n    b.\"UC_Lig_Id\",\n    b.ocorrencia_codigo,\n    b.ref_date,\n    row_number() OVER (\n      PARTITION BY b.\"UC_Lig_Id\"\n      ORDER BY b.ref_date\n    ) AS rn,\n    (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n      - row_number() OVER (\n          PARTITION BY b.\"UC_Lig_Id\"\n          ORDER BY b.ref_date\n        ) AS grp\n  FROM base b\n),\nruns AS (\n  SELECT\n    \"UC_Lig_Id\",\n    ocorrencia_codigo,\n    grp,\n    MIN(ref_date) AS ref1,\n    COUNT(*) AS len\n  FROM seq\n  GROUP BY\n    \"UC_Lig_Id\",\n    ocorrencia_codigo,\n    grp\n  HAVING COUNT(*) >= 3\n)\nSELECT\n  \"UC_Lig_Id\" AS \"Codigo_Ligacao\",\n  to_char(ref1, 'MM/YYYY') AS \"Referencia_1\",\n  to_char(ref1 + INTERVAL '1 month', 'MM/YYYY') AS \"Referencia_2\",\n  to_char(ref1 + INTERVAL '2 month', 'MM/YYYY') AS \"Referencia_3\",\n  ocorrencia_codigo AS \"Codigo_Ocorrencia\"\nFROM runs\nORDER BY\n  \"Codigo_Ligacao\",\n  \"Referencia_1\";\n\nFIM DO EXEMPLO. USE ESTE ESTILO COMO REFERÊNCIA.\n====================================================================\n\nREGRAS PRIORITÁRIAS (NÃO PODE DESCUMPRIR)\n\n1) É PROIBIDO usar COUNT().\n   SEMPRE use COUNT(*).\n\n2) É PROIBIDO escrever extract(year FROM algo)12.\n   SEMPRE escreva extract(year FROM algo)*12.\n\n3) Se o PEDIDO falar de “3 meses consecutivos”, “3 leituras seguidas”,\n   “3 faturas consecutivas” ou equivalente, você DEVE usar a fórmula:\n\n   (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n     - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n\nSe qualquer uma dessas regras for violada na sua consulta, você NÃO pode retorná-la.\nEm vez disso, responda apenas:\n\"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n====================================================================\nENTRADAS\n\n- SCHEMA: objeto JSON (⦃schema⦄) com:\n  • tabelas[*].nome\n  • tabelas[*].colunas[*].nome, .tipo, .pk?, .fk?\n  • relacionamentos[] (from=\"A.x\", to=\"B.y\")\n  • regras.periodo_MMYYYY, regras.streak_MMYYYY,\n    regras.sql_lints, regras.required_patterns,\n    regras.templates, regras.sql_rewrites (se existirem)\n\n- PEDIDO: descrição do que o usuário quer consultar (⦃pedido⦄).\n\n====================================================================\nFONTES DE VERDADE\n\n1) SCHEMA.tabelas/colunas\n2) Relacionamentos explícitos (FKs ou SCHEMA.relacionamentos)\n3) “regras.*” do SCHEMA (SE EXISTIREM) são obrigatórias.\n\nSe algo não existir no SCHEMA, considere que NÃO existe:\nexplique e NÃO gere SQL.\n\n====================================================================\nREGRAS GERAIS\n\n- Gere apenas SELECT (inclui WITH … SELECT).\n  Se pedirem DDL ou DML (CREATE, UPDATE, DELETE, INSERT, DROP, etc.),\n  responda: \"Somente SELECT é permitido.\" e NÃO gere SQL.\n\n- Use apenas tabelas/colunas do SCHEMA.\n\n- JOINS só com relacionamento em alguma fonte (FK ou SCHEMA.relacionamentos).\n  Se não houver caminho de join entre as tabelas solicitadas, explique e NÃO gere SQL.\n\n- Identificadores SEMPRE entre aspas duplas \"…\".\n- Strings SEMPRE com aspas simples '…'.\n\n- Nunca use SELECT *; projete apenas as colunas necessárias.\n- Contagens SEMPRE com COUNT(*).\n\n====================================================================\nPERÍODO MM/YYYY (OBRIGATÓRIO se aplicável)\n\nSe existir SCHEMA.regras.periodo_MMYYYY para a coluna pedida\n(ex.: \"UC_Leitura\".\"UC_Leit_Mes_Ano\"):\n\n- Para filtrar por ano (ex.: 2025), use SEMPRE:\n\n  to_date(coluna, 'MM/YYYY') >= DATE '{{ano}}-01-01'\n  AND to_date(coluna, 'MM/YYYY') <  DATE '{{ano_next}}-01-01'\n\n- É PROIBIDO usar LIKE ou ILIKE para filtrar colunas MM/YYYY cobertas por periodo_MMYYYY.\n  Use SEMPRE to_date(coluna, 'MM/YYYY') e comparação por intervalo de datas.\n\n====================================================================\n3 MESES CONSECUTIVOS (streak_MMYYYY)\n\nSempre que o PEDIDO mencionar:\n\n- \"3 meses consecutivos\", \"3 leituras seguidas\", \"3 leituras consecutivas\",\n- \"3 faturas seguidas\", \"3 referências consecutivas\" ou equivalente,\n\nvocê DEVE aplicar SCHEMA.regras.streak_MMYYYY (se existir).\n\nSe SCHEMA.regras.streak_MMYYYY.metodo = \"row_number_gap\", use:\n\n- pid  = SCHEMA.regras.streak_MMYYYY.pid\n- data = cast = SCHEMA.regras.streak_MMYYYY.cast\n\nPadrão geral:\n\nWITH base AS (\n    SELECT DISTINCT\n        {{pid}}      AS pid,\n        {{cast}}     AS ref_date,\n        -- outras colunas necessárias ao PEDIDO\n        ...\n    FROM <tabela_principal>\n    -- joins conforme relacionamentos do SCHEMA\n    ...\n    WHERE\n        -- filtros do PEDIDO (ex.: ocorrência, ano, etc.)\n        ...\n),\nseq AS (\n    SELECT\n        b.pid,\n        b.ref_date,\n        ...,\n        row_number() OVER (\n            PARTITION BY b.pid\n            ORDER BY b.ref_date\n        ) AS rn,\n        (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n          - row_number() OVER (\n                PARTITION BY b.pid\n                ORDER BY b.ref_date\n            ) AS grp\n    FROM base b\n),\nruns AS (\n    SELECT\n        pid,\n        MIN(ref_date) AS ref1,\n        COUNT(*)      AS len\n    FROM seq\n    GROUP BY pid, grp\n    HAVING COUNT(*) >= COALESCE(SCHEMA.regras.streak_MMYYYY.min_streak_default, 3)\n)\n\nSELECT\n    ...\nFROM runs\n...\n\nRESTRIÇÕES PARA STREAK:\n\n- É PROIBIDO usar LEAD(ref_label) ou auto-join por + INTERVAL '1 month' entre linhas.\n- É OBRIGATÓRIO usar a fórmula do grupo:\n\n  (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n    - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n\n- É OBRIGATÓRIO usar COUNT(*) (nunca COUNT()) no agrupamento de streak.\n\n====================================================================\nUSO DO TEMPLATE DE 3 MESES (SE EXISTIR NO SCHEMA)\n\nSe SCHEMA.regras.templates.tres_meses_consecutivos_generico existir\nE o PEDIDO falar de:\n\n- \"3 meses consecutivos\", \"três meses seguidos\",\n- \"3 leituras consecutivas\", \"3 faturas seguidas\", etc.,\n\nENTÃO:\n\n1) Você NÃO DEVE inventar a query do zero.\n2) Você DEVE usar o SQL de\n   SCHEMA.regras.templates.tres_meses_consecutivos_generico\n   como base.\n\n3) A ÚNICA coisa que você pode alterar são os placeholders:\n\n   - {{padrao}}   → string da ocorrência pedida\n     ex.: 'LEITURA FORA DE FAIXA'\n   - {{ano}}      → ano pedido (ex.: 2025).\n   - {{ano_next}} → ano seguinte (ex.: 2026).\n\n4) É PROIBIDO mudar QUALQUER OUTRA PARTE da query do template:\n\n   - Não mude a fórmula com extract(year FROM ...)*12.\n   - Não mude COUNT(*) para COUNT().\n   - Não mude a estrutura das CTEs (base, seq, runs).\n\n====================================================================\nUSO DE regras.sql_rewrites E regras.required_patterns\n\nSe SCHEMA.regras.sql_rewrites existir, trate-as como um pós-processamento mental\nOBRIGATÓRIO da sua query antes de responder:\n\n- Para cada regra em SCHEMA.regras.sql_rewrites:\n  • Se o padrão da sua query corresponder ao match_regex\n    (por exemplo, COUNT() vazio, ou extract(year ... )12 sem \"*\"),\n    você deve REESCREVER a consulta para usar o texto replace da regra\n    (ex.: trocar COUNT() por COUNT(*), ou\n          (extract(year FROM ...))12 por (extract(year FROM ...)) * 12).\n\nDepois disso, verifique SCHEMA.regras.required_patterns (se existirem):\n\n- Cada item em SCHEMA.regras.required_patterns é um padrão OBRIGATÓRIO.\n- Ajuste a query até que TODOS esses padrões estejam presentes.\n- Para streak de 3 meses, padrões típicos incluem:\n  • row_number() OVER (PARTITION BY \"UC_Lig_Id\" ORDER BY ref_date)\n  • (extract(year FROM b.ref_date)*12 + extract(month FROM b.ref_date))\n  • HAVING COUNT(*) >= 3\n\nSe você não conseguir construir uma consulta que respeite TODAS as regras, NÃO gere SQL.\n\n====================================================================\nCHECKLIST FINAL (AUTO-CHECAGEM)\n\nAntes de responder, revise a SUA PRÓPRIA CONSULTA como texto:\n\n1) Verifique se NENHUM desses problemas aparece:\n   - \"COUNT()\"            (sem nada dentro)\n   - \"extract(year FROM\" seguido diretamente de \"12\" sem \"*\"\n   - LIKE/ILIKE em colunas MM/YYYY cobertas por periodo_MMYYYY\n\n2) Se o PEDIDO for de 3 meses consecutivos, verifique se a query contém:\n   - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n   - a fórmula do grupo com *12:\n     (extract(year FROM ref_date)*12 + extract(month FROM ref_date))\n       - row_number() OVER (PARTITION BY pid ORDER BY ref_date)\n   - HAVING COUNT(*) >= 3\n     (ou o valor de regras.streak_MMYYYY.min_streak_default, se existir)\n\n3) Se QUALQUER item da checagem falhar:\n   - NÃO gere SQL.\n   - Responda apenas:\n     \"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n\n4) Se tudo estiver OK:\n   - Você pode retornar a consulta SQL.\n\n====================================================================\nFORMATO DE RESPOSTA\n\n- Quando a auto-checagem passar:\n  • Retorne APENAS a consulta SQL final (sem comentários, sem JSON, sem explicações).\n\n- Quando a auto-checagem reprovar:\n  • Não retorne SQL.\n  • Responda apenas:\n    \"Falha na auto-checagem: consulta violaria regras do SCHEMA.\"\n","maxIterations":1}},"id":"40cf7729-7b76-44b5-a87e-89ec94df0276","name":"AI Agent","type":"@n8n/n8n-nodes-langchain.agent","position":[-3216,-48],"typeVersion":1.6,"onError":"continueRegularOutput"},{"parameters":{"operation":"fromJson","binaryPropertyName":"json","destinationKey":"json","options":{"encoding":"utf8"}},"id":"575764cb-48bb-473d-8631-f007af361dd9","name":"Extract data from file","type":"n8n-nodes-base.extractFromFile","position":[-3616,-176],"typeVersion":1},{"parameters":{"model":"gpt-5-mini","options":{"maxTokens":32768,"maxRetries":2}},"id":"56b1fba9-86d8-49e7-8f09-8569c4da46b4","name":"OpenAI Chat Model1","type":"@n8n/n8n-nodes-langchain.lmChatOpenAi","position":[-3216,160],"typeVersion":1,"credentials":{"openAiApi":{"id":"H4HnbIJCN7JE8cR5","name":"OpenAi account"}}},{"parameters":{"contextWindowLength":3},"id":"79c35500-3e02-429a-8cae-67d382f6c584","name":"Window Buffer Memory1","type":"@n8n/n8n-nodes-langchain.memoryBufferWindow","position":[-3088,208],"typeVersion":1.2},{"parameters":{"operation":"executeQuery","query":"{{ $('Extract SQL query').item.json.query }}","options":{"connectionTimeout":180}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[-2048,-384],"id":"c317a8c7-6dbc-449f-8026-4b2b92bdd903","name":"Execute a SQL query","alwaysOutputData":true,"executeOnce":false,"credentials":{"postgres":{"id":"6iqsLXZTqf2rK4YA","name":"Postgres account"}},"onError":"continueRegularOutput"},{"parameters":{"assignments":{"assignments":[{"id":"b86f4807-aff3-42fb-a110-f43653368396","name":"Solicitacao","value":"={{ $json.chatInput }}","type":"string"},{"id":"66447438-499c-4ab3-88ee-e20835aa7618","name":"CodigoIManager","value":"=testedev2","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-4304,-176],"id":"ddf38549-ac76-4544-b4a5-fa44f2cc9a9e","name":"Setar informações de Parâmetros"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"f8f105fa-8e7c-4309-9cd9-9a5c987ed77f","leftValue":"={{ $json.allowed }}","rightValue":"","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[-2352,-288],"id":"486e386d-572a-4aeb-8859-8b7680e4df40","name":"If1"},{"parameters":{"jsCode":"// Run Once for All Items\n\nconst items = $input.all();\n\n// --- Utils ------------------------------------------------------------------\n\nfunction hasMeaningfulContent(o, depth = 0) {\n  if (o == null) return false;\n  if (typeof o !== 'object') return String(o).trim() !== '';\n  if (depth > 6) return true;\n  if (Array.isArray(o)) return o.some(v => hasMeaningfulContent(v, depth + 1));\n  const keys = Object.keys(o);\n  if (keys.length === 0) return false;\n  return keys.some(k => hasMeaningfulContent(o[k], depth + 1));\n}\n\nfunction collectErrorsDeep(obj, found = []) {\n  if (obj == null) return found;\n\n  const pushErr = (val) => {\n    if (val == null) return;\n    const msg = typeof val === 'object' ? JSON.stringify(val) : String(val);\n    if (msg.trim()) found.push(msg.trim());\n  };\n\n  if (Array.isArray(obj)) {\n    for (const v of obj) collectErrorsDeep(v, found);\n    return found;\n  }\n\n  if (typeof obj === 'object') {\n    for (const [k, v] of Object.entries(obj)) {\n      const lower = k.toLowerCase();\n      if (lower === 'erro' || lower === 'error') pushErr(v);\n      else if (lower === 'message' && typeof v === 'string') pushErr(v);\n      collectErrorsDeep(v, found);\n    }\n    return found;\n  }\n\n  return found;\n}\n\nfunction dedupStrings(arr) {\n  const seen = new Set();\n  const out = [];\n  for (const s of arr) if (!seen.has(s)) { seen.add(s); out.push(s); }\n  return out;\n}\n\n// Preferência do Luis: $json.message.content.data\nfunction extractUsefulPayload(j) {\n  if (Array.isArray(j?.message?.content?.data)) return j.message.content.data.slice();\n  if (Array.isArray(j?.data)) return j.data.slice();\n  if (hasMeaningfulContent(j)) return [j];\n  return [];\n}\n\nfunction normalizeList(list) {\n  return list\n    .map(x => (x?.json ?? x))\n    .filter(o => hasMeaningfulContent(o))\n    .map(o => (typeof o === 'object' ? o : { value: o }));\n}\n\n// Captura a query de forma resiliente (suporta Set, Function e mesmo payload)\nfunction safeGetQuery() {\n  // 1) Se a query veio nos itens de entrada\n  for (const it of items) {\n    const j = it?.json ?? {};\n    const q = j.query ?? j.sql ?? j.consulta;\n    if (typeof q === 'string' && q.trim()) return q.trim();\n  }\n\n  // 2) Caso a query esteja em outro nó do fluxo\n  try {\n    // Ajuste para o nome do nó onde a SQL é montada\n    const fromNode = $items('Extrair query', 0, 0);\n    for (const it of fromNode ?? []) {\n      const j = it?.json ?? {};\n      const q = j.query ?? j.sql ?? j.consulta;\n      if (typeof q === 'string' && q.trim()) return q.trim();\n    }\n  } catch (_) { /* ignora erros */ }\n\n  return null; // não encontrada\n}\n\n// --- Fluxo ------------------------------------------------------------------\n\n// Captura a query logo no início, para usá-la em QUALQUER retorno\nconst query = safeGetQuery();\n\nconsole.log(query)\n\n// 1) Sem entradas\nif (!items || items.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação', query, errors: ['Input vazio'] } }];\n}\n\n// 2) Procure erros em todo o payload bruto\nlet outerErrors = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  collectErrorsDeep(j, outerErrors);\n}\nouterErrors = dedupStrings(outerErrors);\n\n// 3) Se achou erro, retorna { Erro, query, errors }\nif (outerErrors.length > 0) {\n  return [{ json: { Erro: outerErrors[0], query, errors: outerErrors } }];\n}\n\n// 4) Extrair dados dos formatos suportados\nlet all = [];\nfor (const it of items) {\n  const j = it?.json ?? {};\n  all.push(...extractUsefulPayload(j));\n}\n\n// 5) Fallback: cada item.json\nif (all.length === 0) {\n  all = items.map(i => i?.json ?? {});\n}\n\n// 6) Checar erros dentro da lista\nlet innerErrors = [];\ncollectErrorsDeep(all, innerErrors);\ninnerErrors = dedupStrings(innerErrors);\nif (innerErrors.length > 0) {\n  const errors = dedupStrings([...outerErrors, ...innerErrors]);\n  return [{ json: { Erro: innerErrors[0], query, errors } }];\n}\n\n// 7) Limpeza de dados\nconst rows = normalizeList(all);\n\n// 8) Sem dados → erro padrão (com query e errors)\nif (rows.length === 0) {\n  return [{ json: { Erro: 'Não foram encontrados dados para esta solicitação', query, errors: [] } }];\n}\n\n// 9) OK: retorna SEMPRE { data, query, errors: [] }\nreturn [{ json: { data: rows, query, errors: [] } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-1824,-32],"id":"1a5c75f8-bfc4-449b-99ef-913aa745ddd4","name":"Repassar dados"},{"parameters":{"jsCode":"// Entrada: { sql: \"SELECT ...\", userPrompt: \"...\" }  (ajuste nomes se preciso)\nlet sql = ($('Extract SQL query').first().json.query || \"\").trim();\n\n// 1) Remove comentários (-- e /* */) e normaliza espaços\nconst stripComments = s => {\n  // remove /* ... */ (multilinha)\n  s = s.replace(/\\/\\*[\\s\\S]*?\\*\\//g, ' ');\n  // remove -- até o fim da linha\n  s = s.replace(/--.*$/gm, ' ');\n  return s;\n};\n\n/**\n * Sanitiza a SQL corrigindo problemas de sintaxe conhecidos\n * (COUNT() vazio e extract(year FROM ...)12 sem \"*\").\n *\n * A ideia é semelhante ao stripComments: recebe a string e\n * devolve a string sanitizada de uma vez só.\n */\nconst sanitizeSql = s => {\n  let out = s;\n\n  // 1) Corrige COUNT() → COUNT(*)\n  //    - pega qualquer COUNT(   ) possivelmente com espaços\n  out = out.replace(/COUNT\\s*\\(\\s*\\)/gi, 'COUNT(*)');\n\n  // 2) Corrige extract(year FROM algo)12 → extract(year FROM algo)*12\n  //    - captura o conteúdo dentro de year FROM ... )\n  //    - permite espaços variados\n  out = out.replace(\n    /extract\\s*\\(\\s*year\\s+from\\s+([^)]+)\\)\\s*12/gi,\n    'extract(year FROM $1)*12'\n\n  );\n\n  return out;\n};\n\nconst cleaned = stripComments(sql).replace(/\\s+/g, ' ').trim();\n\n\nconst forbidden = /\\b(SOMENTE|INSERT|UPDATE|DELETE|MERGE|CREATE|ALTER|DROP|TRUNCATE|GRANT|REVOKE|COMMENT|VACUUM|COPY|REFRESH|CALL|DO|BEGIN|COMMIT|ROLLBACK|SET|LOCK|CLUSTER|REINDEX|DISCARD)\\b/i;\nif (forbidden.test(cleaned)) {\n  return [{ \n    allowed: false,\n    reason: \"Contém comando proibido.\", \n    erro: `Somente SELECT é permitido. Não posso executar DDL/DML.\n    Detalhes: ` + $input.first().json.output\n  }];\n}\n\nlet sqlSanitized = sanitizeSql(sql);\n\nreturn [{allowed: true, sql: sqlSanitized }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2544,-288],"id":"1463ae1d-503d-4d4d-a543-7c28ac0b3716","name":"Extrair query"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Run Once for Each Item\n// devolve UM item por entrada (sem colchetes)\nconst msg = $json.output; \nreturn {\n  json: {\n      erro:msg ?? \"Por favor, forneça a consulta ou pergunta específica que deseja realizar com base no esquema fornecido.\"\n  }\n};\n\n\n\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2496,-144],"id":"92979ca4-4c47-4cb1-9dc5-975140d48b8c","name":"Mensagem de query inválida"},{"parameters":{"mode":"runOnceForEachItem","jsCode":"// Run Once for Each Item\n/**\n const msg = \"Solicitação contém comando proibido, somente SELECT é permitido. Não posso executar DDL/DML.\";\n */\nconst msg = $json.erro;\nreturn {\n  json: { erro: msg }\n};\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-2080,-224],"id":"bd552156-6b5d-4c48-b18d-525528abbe63","name":"Mensagem de query Proibida"},{"parameters":{"jsCode":"const item = $input.item;\nconst j = item.json;\n\nconst configuracaoPorCliente = {\n  \"0001\": {\n    CNPJ: $input.first().json.CNPJ,\n    host: \"52.45.149.188\",\n    database: \"icommercial_faturamento_teste_luis\",\n    user: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"3738\": {\n    CNPJ: $input.first().json.CNPJ,\n    host: \"52.45.149.188\",\n    database: \"icommercial_faturamento_teste_luis\",\n    user: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n  \"testedev2\": {\n    CNPJ: $input.first().json.CNPJ,\n    host: \"rabbitmq.icommercial002.inovamobil.com.br\",\n    database: \"icommercial_faturamento_testedev2\",\n    user: \"postgres\",\n    senha: \"idb#inov@19#\",\n    porta: 5432,\n  },\n};\n\n// ==== OBRIGATÓRIO TER código do IManager ====\nconst codigoIManager = (j.CodigoIManager ?? \"testedev2\");\nconst selected = configuracaoPorCliente[codigoIManager];\nif (!selected) {\n  throw new Error(\n    `Cliente ` + codigoIManager + ` não informado, favor validar para utilização do módulo.`\n  );\n}\n\n\nj.configuracao = {\n    host: selected.host,\n    database: selected.database,\n    user: selected.user,\n    password: selected.senha,\n    port: selected.porta,\n  };\n\nreturn item;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-4064,-176],"id":"2d674ee9-3c7c-4383-8681-8541defc4c84","name":"Constantes"},{"parameters":{"public":true,"options":{"responseMode":"responseNodes"}},"type":"@n8n/n8n-nodes-langchain.chatTrigger","typeVersion":1.3,"position":[-4640,-160],"id":"ec93f68f-129e-4d72-8c24-8ec7eb46ef49","name":"When chat message received","webhookId":"e4ca9d61-6106-44cd-aa52-625d59836fac"},{"parameters":{"message":"=```json\n{{ JSON.stringify($json, null, 2) }}","waitUserReply":false,"options":{}},"type":"@n8n/n8n-nodes-langchain.chat","typeVersion":1,"position":[-1552,-32],"id":"de9385f7-495c-4b48-ad04-431c0bfe404d","name":"Respond to Chat","executeOnce":false,"alwaysOutputData":false,"onError":"continueRegularOutput"}],"connections":{"Download file":{"main":[[{"node":"Extract data from file","type":"main","index":0}]]},"Check if query exists":{"main":[[{"node":"Extrair query","type":"main","index":0}],[{"node":"Mensagem de query inválida","type":"main","index":0}]]},"Extract SQL query":{"main":[[{"node":"Check if query exists","type":"main","index":0}]]},"Combine schema data and chat input":{"main":[[{"node":"AI Agent","type":"main","index":0}]]},"AI Agent":{"main":[[{"node":"Extract SQL query","type":"main","index":0}]]},"Extract data from file":{"main":[[{"node":"Combine schema data and chat input","type":"main","index":0}]]},"OpenAI Chat Model1":{"ai_languageModel":[[{"node":"AI Agent","type":"ai_languageModel","index":0}]]},"Window Buffer Memory1":{"ai_memory":[[{"node":"AI Agent","type":"ai_memory","index":0}]]},"Execute a SQL query":{"main":[[{"node":"Repassar dados","type":"main","index":0}]]},"Setar informações de Parâmetros":{"main":[[{"node":"Constantes","type":"main","index":0}]]},"If1":{"main":[[{"node":"Execute a SQL query","type":"main","index":0}],[{"node":"Mensagem de query Proibida","type":"main","index":0}]]},"Repassar dados":{"main":[[{"node":"Respond to Chat","type":"main","index":0}]]},"Extrair query":{"main":[[{"node":"If1","type":"main","index":0}]]},"Mensagem de query inválida":{"main":[[{"node":"Repassar dados","type":"main","index":0}]]},"Mensagem de query Proibida":{"main":[[{"node":"Repassar dados","type":"main","index":0}]]},"Constantes":{"main":[[{"node":"Download file","type":"main","index":0}]]},"When chat message received":{"main":[[{"node":"Setar informações de Parâmetros","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"a1393703-5f25-4e49-8b0d-88fe40864a76","triggerCount":1,"shared":[{"createdAt":"2025-08-14T20:21:27.413Z","updatedAt":"2025-08-14T20:21:27.413Z","role":"workflow:owner","workflowId":"BF29DJ5zVE9DR2Tk","projectId":"bDUBly1zU3yziLIn"}],"tags":[]}